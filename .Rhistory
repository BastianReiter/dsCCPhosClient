Test <- .encode_tidy_eval(FilterExpression, .get_encode_dictionary())
Test
Test2 <- .decode_tidy_eval(Test, .get_encode_dictionary())
Test2
# --- For Testing Purposes ---
TableName <- "CDS_Patient"
FilterExpression <- "LastVitalStatus == 'Alive'"
GroupBy <- NULL
OutputName <- "Test"
DSConnections <- CCPConnections
FilterExpression <- .encode_tidy_eval(FilterExpression, .get_encode_dictionary())
# Execute server-side assign function
DSI::datashield.assign(conns = DSConnections,
symbol = OutputName,
value = call("FilterTableDS",
TableName.S = TableName,
FilterExpression.S = FilterExpression,
GroupBy.S = GroupBy))
rm(list = ls())
UpdateLocalPackages()
library(dsBaseClient)
library(dsCCPhosClient)
library(dsTidyverseClient)
library(resourcer)
# Print DataSHIELD errors right away
options(datashield.errors.print = TRUE)
#TestData <- readRDS("../dsCCPhos/Development/Data/RealData/CCPRealData_Frankfurt.rds")
TestData <- readRDS("../dsCCPhos/Development/Data/TestData/CCPTestData.rds")
# Definition of test resource, exemplary with local csv-file
TestResource <- resourcer::newResource(name = "TestResource",
#url = "file://./Development/Test/DummyData.csv",
url = "file://localhost/C:/Users/Basti/ARBEIT Lokal/dsCCPhosClient/Development/Test/DummyData.csv",
format = "csv")
CCPConnections <- ConnectToVirtualCCP(CCPTestData = TestData,
NumberOfServers = 3,
NumberOfPatientsPerServer = 2000,
AddedDsPackages = "dsTidyverse")
Messages <- LoadRawDataSet(ServerSpecifications = NULL)
devtools::load_all(".")
library(dsBaseClient)
library(dsCCPhosClient)
library(dsTidyverseClient)
library(resourcer)
# Print DataSHIELD errors right away
options(datashield.errors.print = TRUE)
#TestData <- readRDS("../dsCCPhos/Development/Data/RealData/CCPRealData_Frankfurt.rds")
TestData <- readRDS("../dsCCPhos/Development/Data/TestData/CCPTestData.rds")
# Definition of test resource, exemplary with local csv-file
TestResource <- resourcer::newResource(name = "TestResource",
#url = "file://./Development/Test/DummyData.csv",
url = "file://localhost/C:/Users/Basti/ARBEIT Lokal/dsCCPhosClient/Development/Test/DummyData.csv",
format = "csv")
CCPConnections <- ConnectToVirtualCCP(CCPTestData = TestData,
NumberOfServers = 3,
NumberOfPatientsPerServer = 2000,
AddedDsPackages = "dsTidyverse")
Requirements <- CheckServerRequirements()
Messages <- LoadRawDataSet(ServerSpecifications = NULL)
ds.DrawSample(RawDataSetName = "RawDataSet",
SampleSize = "1000",
SampleName = "RDSSample")
# Transform Raw Data Set (RDS) into Curated Data Set (CDS) (using default settings)
Curation <- ds.CurateData(RawDataSetName = "RawDataSet",
Settings = NULL,
OutputName = "CurationOutput")
# --- For Testing Purposes ---
TableName <- "CDS_Patient"
FilterExpression <- "LastVitalStatus == 'Alive'"
GroupBy <- NULL
OutputName <- "Test"
DSConnections <- CCPConnections
# Encode string in 'FilterExpression' to make it passable through DSI
FilterExpression <- .encode_tidy_eval(FilterExpression, .get_encode_dictionary())
# Execute server-side assign function
DSI::datashield.assign(conns = DSConnections,
symbol = OutputName,
value = call("FilterTableDS",
TableName.S = TableName,
FilterExpression.S = FilterExpression,
GroupBy.S = GroupBy))
# Make tables from Curated Data Set directly addressable by unpacking them into R server session
Messages <- ds.UnpackCuratedDataSet(CuratedDataSetName = "CuratedDataSet")
rm(DSConnections)
# Make tables from Curated Data Set directly addressable by unpacking them into R server session
Messages <- ds.UnpackCuratedDataSet(CuratedDataSetName = "CuratedDataSet")
DSConnections <- CCPConnections
# Execute server-side assign function
DSI::datashield.assign(conns = DSConnections,
symbol = OutputName,
value = call("FilterTableDS",
TableName.S = TableName,
FilterExpression.S = FilterExpression,
GroupBy.S = GroupBy))
Test <- DSLite::getDSLiteData(conns = CCPConnections, "Test")
View(Test$ServerA)
FilterExpression <- "LastVitalStatus == 'Alive' & Gender == 'male'"
# Encode string in 'FilterExpression' to make it passable through DSI
FilterExpression <- .encode_tidy_eval(FilterExpression, .get_encode_dictionary())
# Execute server-side assign function
DSI::datashield.assign(conns = DSConnections,
symbol = OutputName,
value = call("FilterTableDS",
TableName.S = TableName,
FilterExpression.S = FilterExpression,
GroupBy.S = GroupBy))
View(Test$ServerA)
FilterExpression <- "LastVitalStatus == 'Alive' & Gender == 'Male'"
# Encode string in 'FilterExpression' to make it passable through DSI
FilterExpression <- .encode_tidy_eval(FilterExpression, .get_encode_dictionary())
# Execute server-side assign function
DSI::datashield.assign(conns = DSConnections,
symbol = OutputName,
value = call("FilterTableDS",
TableName.S = TableName,
FilterExpression.S = FilterExpression,
GroupBy.S = GroupBy))
Test <- DSLite::getDSLiteData(conns = CCPConnections, "Test")
View(Test$ServerA)
View(Test$ServerA)
FilterExpression <- "LastVitalStatus == 'Alive' & str_starts(Gender, 'Ma')"
# Encode string in 'FilterExpression' to make it passable through DSI
FilterExpression <- .encode_tidy_eval(FilterExpression, .get_encode_dictionary())
# Execute server-side assign function
DSI::datashield.assign(conns = DSConnections,
symbol = OutputName,
value = call("FilterTableDS",
TableName.S = TableName,
FilterExpression.S = FilterExpression,
GroupBy.S = GroupBy))
Test <- DSLite::getDSLiteData(conns = CCPConnections, "Test")
View(Test$ServerA)
# Collect comprehensive information about all workspace objects
ServerWorkspaceInfo <- GetServerWorkspaceInfo()
rm(DSConnections)
# Collect comprehensive information about all workspace objects
ServerWorkspaceInfo <- GetServerWorkspaceInfo()
# Overview of all objects in server R sessions
View(ServerWorkspaceInfo$Overview)
# Detailed meta data of a particular object (also part of ServerWorkspaceInfo)
ObjectMetaData <- ds.GetObjectMetaData(ObjectName = "ADS_Patient")
# Explore Object meta data: Structural overview
View(ObjectMetaData$ServerA$Structure)
ObjectMetaData$ServerA$ObjectExists
# Detailed meta data of a particular object (also part of ServerWorkspaceInfo)
ObjectMetaData <- ds.GetObjectMetaData(ObjectName = "CDS_Patient")
# Explore Object meta data: Structural overview
View(ObjectMetaData$ServerA$Structure)
devtools::load_all(".")
devtools::load_all(".")
library(dsBaseClient)
library(dsCCPhosClient)
library(dsTidyverseClient)
library(resourcer)
# Print DataSHIELD errors right away
options(datashield.errors.print = TRUE)
#TestData <- readRDS("../dsCCPhos/Development/Data/RealData/CCPRealData_Frankfurt.rds")
TestData <- readRDS("../dsCCPhos/Development/Data/TestData/CCPTestData.rds")
# Definition of test resource, exemplary with local csv-file
TestResource <- resourcer::newResource(name = "TestResource",
#url = "file://./Development/Test/DummyData.csv",
url = "file://localhost/C:/Users/Basti/ARBEIT Lokal/dsCCPhosClient/Development/Test/DummyData.csv",
format = "csv")
CCPConnections <- ConnectToVirtualCCP(CCPTestData = TestData,
NumberOfServers = 3,
NumberOfPatientsPerServer = 2000,
AddedDsPackages = "dsTidyverse")
Messages <- LoadRawDataSet(ServerSpecifications = NULL)
ds.DrawSample(RawDataSetName = "RawDataSet",
SampleSize = "1000",
SampleName = "RDSSample")
# Transform Raw Data Set (RDS) into Curated Data Set (CDS) (using default settings)
Curation <- ds.CurateData(RawDataSetName = "RawDataSet",
Settings = NULL,
OutputName = "CurationOutput")
# Make tables from Curated Data Set directly addressable by unpacking them into R server session
Messages <- ds.UnpackCuratedDataSet(CuratedDataSetName = "CuratedDataSet")
# --- For Testing Purposes ---
TableName <- "CDS_Staging"
FeatureName <- "TNM_T"
DSConnections <- CCPConnections
require(dsBaseClient)
require(dplyr)
require(purrr)
# Get meta data of table object
TableMetaData <- ds.GetObjectMetaData(ObjectName = TableName,
DSConnections = DSConnections)
# Stop execution if referred table object is not a data.frame
if (TableMetaData$FirstEligible$Class != "data.frame") { stop("Error: The referred table object does not seem to be a data.frame.", call. = FALSE)}
# ServerReturns: Obtain feature properties for each server calling dsCCPhos::GetFeatureInfoDS()
ServerReturns <- DSI::datashield.aggregate(conns = DSConnections,
expr = call("GetFeatureInfoDS",
TableName.S = TableName,
FeatureName.S = FeatureName))
# Convert Server returns into tibble containing separate feature meta data
SeparateProperties <- ServerReturns %>%
list_rbind(names_to = "Server")
# Obtaining return value for cumulated feature data type
ReturnedFeatureDataTypes <- unique(SeparateProperties$DataType[!is.na(SeparateProperties$DataType)])
CumulatedDataType <- NA
if (length(ReturnedFeatureDataTypes) == 1) { CumulatedDataType <- ReturnedFeatureDataTypes }
if (length(ReturnedFeatureDataTypes) > 1) { CumulatedDataType <- "Inconclusive"}
# Obtain cumulated feature meta data
CumulatedProperties <- tibble(Server = "All",
DataType = CumulatedDataType,
N_Total = sum(SeparateProperties$N_Total),
N_Valid = sum(SeparateProperties$N_Valid),
ValidProportion = N_Valid / N_Total,
N_Missing = sum(SeparateProperties$N_Missing),
MissingProportion = N_Missing / N_Total)
# Obtain cumulated feature meta data
CumulatedProperties <- tibble(Server = "All",
DataType = CumulatedDataType,
N.Total = sum(SeparateProperties$N.Total),
N.Valid = sum(SeparateProperties$N.Valid),
ValidProportion = N.Valid / N.Total,
N.Missing = sum(SeparateProperties$N_Missing),
MissingProportion = N.Missing / N.Total)
# Obtain cumulated feature meta data
CumulatedProperties <- tibble(Server = "All",
DataType = CumulatedDataType,
N.Total = sum(SeparateProperties$N.Total),
N.Valid = sum(SeparateProperties$N.Valid),
ValidProportion = N.Valid / N.Total,
N.Missing = sum(SeparateProperties$N.Missing),
MissingProportion = N.Missing / N.Total)
CumulatedProperties
EligibleValues <- NULL
# If Feature of concern is of class character
if (CumulatedDataType == "character")
{
EligibleValues <- GetEligibleValues(TableName = TableName,
FeatureName = FeatureName)
}
EligibleValues
dsCCPhosClient::Meta_Values
devtools::load_all(".")
EligibleValues <- GetEligibleValues(TableName = TableName,
FeatureName = FeatureName)
EligibleValues
View(dsCCPhosClient::Meta_Values)
# --- For Testing Purposes ---
TableName = "Surgery"
FeatureName = "Intention"
Stage = "Curated"
EligibleValues <- dsCCPhosClient::Meta_Values %>%
filter(Table == TableName,
Feature == FeatureName) %>%
{ if (Stage == "Raw") { pull(., Value_Raw) }
else { pull(., Value_Curated) } }
EligibleValues
# --- For Testing Purposes ---
TableName <- "CDS_Staging"
FeatureName <- "TNM_T"
DSConnections <- CCPConnections
EligibleValues <- GetEligibleValues(TableName = TableName,
FeatureName = FeatureName)
EligibleValues
# Get meta data of table object
TableMetaData <- ds.GetObjectMetaData(ObjectName = TableName,
DSConnections = DSConnections)
# Stop execution if referred table object is not a data.frame
if (TableMetaData$FirstEligible$Class != "data.frame") { stop("Error: The referred table object does not seem to be a data.frame.", call. = FALSE)}
# ServerReturns: Obtain feature properties for each server calling dsCCPhos::GetFeatureInfoDS()
ServerReturns <- DSI::datashield.aggregate(conns = DSConnections,
expr = call("GetFeatureInfoDS",
TableName.S = TableName,
FeatureName.S = FeatureName))
# Convert Server returns into tibble containing separate feature meta data
SeparateProperties <- ServerReturns %>%
list_rbind(names_to = "Server")
# Obtaining return value for cumulated feature data type
ReturnedFeatureDataTypes <- unique(SeparateProperties$DataType[!is.na(SeparateProperties$DataType)])
CumulatedDataType <- NA
if (length(ReturnedFeatureDataTypes) == 1) { CumulatedDataType <- ReturnedFeatureDataTypes }
if (length(ReturnedFeatureDataTypes) > 1) { CumulatedDataType <- "Inconclusive"}
# Obtain cumulated feature meta data
CumulatedProperties <- tibble(Server = "All",
DataType = CumulatedDataType,
N.Total = sum(SeparateProperties$N.Total),
N.Valid = sum(SeparateProperties$N.Valid),
ValidProportion = N.Valid / N.Total,
N.Missing = sum(SeparateProperties$N.Missing),
MissingProportion = N.Missing / N.Total)
EligibleValues <- NULL
# If Feature of concern is of class character
if (CumulatedDataType == "character")
{
EligibleValues <- GetEligibleValues(TableName = TableName,
FeatureName = FeatureName)
}
EligibleValues
GetEligibleValues("Staging", "TNM_T")
EligibleValues <- GetEligibleValues(TableName,
FeatureName)
EligibleValues
devtools::load_all(".")
devtools::load_all(".")
library(dsBaseClient)
library(dsCCPhosClient)
library(dsTidyverseClient)
library(resourcer)
# Print DataSHIELD errors right away
options(datashield.errors.print = TRUE)
#TestData <- readRDS("../dsCCPhos/Development/Data/RealData/CCPRealData_Frankfurt.rds")
TestData <- readRDS("../dsCCPhos/Development/Data/TestData/CCPTestData.rds")
# Definition of test resource, exemplary with local csv-file
TestResource <- resourcer::newResource(name = "TestResource",
#url = "file://./Development/Test/DummyData.csv",
url = "file://localhost/C:/Users/Basti/ARBEIT Lokal/dsCCPhosClient/Development/Test/DummyData.csv",
format = "csv")
CCPConnections <- ConnectToVirtualCCP(CCPTestData = TestData,
NumberOfServers = 3,
NumberOfPatientsPerServer = 2000,
AddedDsPackages = "dsTidyverse")
Requirements <- CheckServerRequirements()
Messages <- LoadRawDataSet(ServerSpecifications = NULL)
# Transform Raw Data Set (RDS) into Curated Data Set (CDS) (using default settings)
Curation <- ds.CurateData(RawDataSetName = "RawDataSet",
Settings = NULL,
OutputName = "CurationOutput")
# Make tables from Curated Data Set directly addressable by unpacking them into R server session
Messages <- ds.UnpackCuratedDataSet(CuratedDataSetName = "CuratedDataSet")
# Collect comprehensive information about all workspace objects
ServerWorkspaceInfo <- GetServerWorkspaceInfo()
# Overview of all objects in server R sessions
View(ServerWorkspaceInfo$Overview)
View(ServerWorkspaceInfo$Details$CDS_Patient)
View(ServerWorkspaceInfo$Details$CDS_Patient$Structure)
View(ServerWorkspaceInfo$Details$CDS_Patient$DataTypes)
View(ServerWorkspaceInfo$Details$CDS_Patient$RowCount)
View(ServerWorkspaceInfo$Details)
Tlist <- list(abm = "fhjs", sjh = "fkjh")
Tlist[NULL]
Tlist[[NULL]]
# --- For Testing Purposes ---
DSConnections <- CCPConnections
# Get server names (sorted alphabetically)
ServerNames <- sort(names(DSConnections))
ServerObjectNames <- DSI::datashield.symbols(conns = DSConnections)
# Get all uniquely occurring object names across servers (although usually the set of symbol names should be the same on all servers)
UniqueObjectNames <- sort(unique(unlist(ServerObjectNames)))
# Initiate 'ObjectInfo' tibble
ObjectInfoComplete <- tibble()
MetaDataComplete <- list()
i <- 1
#print(i)
ObjectInfo <- tibble(Object = UniqueObjectNames)
ObjectInfo$ObjectExists <- ObjectInfo$Object %in% ServerObjectNames[[ServerNames[i]]]
ObjectInfo$Object
ObjectInfo$ObjectExists
length(ObjectInfo$ObjectExists)
dsBaseClient::ds.exists(x = "RDS_GeneralCondition", datasources = CCPConnections)
MetaData <- ObjectInfo$Object %>%
map(function(object)
{
ObjectMetaData <- ds.GetObjectMetaData(ObjectName = object,
DSConnections = DSConnections[i])
return(ObjectMetaData$FirstEligible)      # The meta data for an object is collected from the first server where the object actually exists (in case it does not exist everywhere)
}) %>%
setNames(ObjectInfo$Object)
View(ObjectInfo)
View(Meta_Data)
View(MetaData)
View(MetaData$CDS_GeneralCondition)
# Add some meta data to 'ObjectInfo'
ObjectInfo <- ObjectInfo %>%
rowwise() %>%
mutate(Class = ifelse(!is.null(MetaData[[Object]]$Class), MetaData[[Object]]$Class, NA),
Length = ifelse(!is.null(MetaData[[Object]]$Length), MetaData[[Object]]$Length, NA),
RowCount = ifelse(!is.null(MetaData[[Object]]$RowCount), MetaData[[Object]]$RowCount, NA),
.after = Object) %>%
ungroup() %>%
mutate(ServerName = ServerNames[i], .before = 1)
# Get server names (sorted alphabetically)
ServerNames <- sort(names(DSConnections))
ServerObjectNames <- DSI::datashield.symbols(conns = DSConnections)
# Get all uniquely occurring object names across servers (although usually the set of symbol names should be the same on all servers)
UniqueObjectNames <- sort(unique(unlist(ServerObjectNames)))
# Initiate 'ObjectInfo' tibble
ObjectInfoComplete <- tibble()
MetaDataComplete <- list()
for (i in 1:length(ServerNames))
{
#print(i)
ObjectInfo <- tibble(Object = UniqueObjectNames)
ObjectInfo$ObjectExists <- ObjectInfo$Object %in% ServerObjectNames[[ServerNames[i]]]
#ServerColumns <- cbind(ServerColumns,      # Using cbind() instead of bind_cols() because it's quiet
#                       Column)
#}
# Name columns according to server names
#colnames(ServerColumns) <- "ObjectExists"
# Bind columns to Output data frame
# ObjectInfo <- bind_cols(ObjectInfo,
#                        ServerColumns)
# 2) Collect meta data about existing objects and attach some of it to 'ObjectInfo'
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
MetaData <- ObjectInfo$Object %>%
map(function(object)
{
ObjectMetaData <- ds.GetObjectMetaData(ObjectName = object,
DSConnections = DSConnections[i])
return(ObjectMetaData$FirstEligible)      # The meta data for an object is collected from the first server where the object actually exists (in case it does not exist everywhere)
}) %>%
setNames(ObjectInfo$Object)
# Add some meta data to 'ObjectInfo'
ObjectInfo <- ObjectInfo %>%
rowwise() %>%
mutate(Class = ifelse(!is.null(MetaData[[Object]]$Class), MetaData[[Object]]$Class, NA),
Length = ifelse(!is.null(MetaData[[Object]]$Length), MetaData[[Object]]$Length, NA),
RowCount = ifelse(!is.null(MetaData[[Object]]$RowCount), MetaData[[Object]]$RowCount, NA),
.after = Object) %>%
ungroup() %>%
mutate(ServerName = ServerNames[i], .before = 1)
ObjectInfoComplete <- rbind(ObjectInfoComplete, ObjectInfo)
MetaDataComplete[[i]] <- MetaData
names(MetaDataComplete)[i] <- ServerNames[i]
}
rm(list=ls())
library(dsBaseClient)
library(dsCCPhosClient)
library(dsTidyverseClient)
library(resourcer)
# Print DataSHIELD errors right away
options(datashield.errors.print = TRUE)
#TestData <- readRDS("../dsCCPhos/Development/Data/RealData/CCPRealData_Frankfurt.rds")
TestData <- readRDS("../dsCCPhos/Development/Data/TestData/CCPTestData.rds")
# Definition of test resource, exemplary with local csv-file
TestResource <- resourcer::newResource(name = "TestResource",
#url = "file://./Development/Test/DummyData.csv",
url = "file://localhost/C:/Users/Basti/ARBEIT Lokal/dsCCPhosClient/Development/Test/DummyData.csv",
format = "csv")
CCPConnections <- ConnectToVirtualCCP(CCPTestData = TestData,
NumberOfServers = 3,
NumberOfPatientsPerServer = 2000,
AddedDsPackages = "dsTidyverse")
Requirements <- CheckServerRequirements()
# --- For Testing Purposes ---
DSConnections <- CCPConnections
# Get server names (sorted alphabetically)
ServerNames <- sort(names(DSConnections))
ServerObjectNames <- DSI::datashield.symbols(conns = DSConnections)
# Get all uniquely occurring object names across servers (although usually the set of symbol names should be the same on all servers)
UniqueObjectNames <- sort(unique(unlist(ServerObjectNames)))
# Initiate 'ObjectInfo' tibble
ObjectInfoComplete <- tibble()
MetaDataComplete <- list()
for (i in 1:length(ServerNames))
{
#print(i)
ObjectInfo <- tibble(Object = UniqueObjectNames)
ObjectInfo$ObjectExists <- ObjectInfo$Object %in% ServerObjectNames[[ServerNames[i]]]
#ServerColumns <- cbind(ServerColumns,      # Using cbind() instead of bind_cols() because it's quiet
#                       Column)
#}
# Name columns according to server names
#colnames(ServerColumns) <- "ObjectExists"
# Bind columns to Output data frame
# ObjectInfo <- bind_cols(ObjectInfo,
#                        ServerColumns)
# 2) Collect meta data about existing objects and attach some of it to 'ObjectInfo'
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
MetaData <- ObjectInfo$Object %>%
map(function(object)
{
ObjectMetaData <- ds.GetObjectMetaData(ObjectName = object,
DSConnections = DSConnections[i])
return(ObjectMetaData$FirstEligible)      # The meta data for an object is collected from the first server where the object actually exists (in case it does not exist everywhere)
}) %>%
setNames(ObjectInfo$Object)
# Add some meta data to 'ObjectInfo'
ObjectInfo <- ObjectInfo %>%
rowwise() %>%
mutate(Class = ifelse(!is.null(MetaData[[Object]]$Class), MetaData[[Object]]$Class, NA),
Length = ifelse(!is.null(MetaData[[Object]]$Length), MetaData[[Object]]$Length, NA),
RowCount = ifelse(!is.null(MetaData[[Object]]$RowCount), MetaData[[Object]]$RowCount, NA),
.after = Object) %>%
ungroup() %>%
mutate(ServerName = ServerNames[i], .before = 1)
ObjectInfoComplete <- rbind(ObjectInfoComplete, ObjectInfo)
MetaDataComplete[[i]] <- MetaData
names(MetaDataComplete)[i] <- ServerNames[i]
}
devtools::load_all(".")
# Collect comprehensive information about all workspace objects
ServerWorkspaceInfo <- GetServerWorkspaceInfo()
(rm(DSConnections))
rm(DSConnections)
# Collect comprehensive information about all workspace objects
ServerWorkspaceInfo <- GetServerWorkspaceInfo()
ServerWorkspaceInfo
devtools::load_all(".")
devtools::load_all(".")
library(dsBaseClient)
library(dsCCPhosClient)
library(dsTidyverseClient)
library(resourcer)
# Print DataSHIELD errors right away
options(datashield.errors.print = TRUE)
#TestData <- readRDS("../dsCCPhos/Development/Data/RealData/CCPRealData_Frankfurt.rds")
TestData <- readRDS("../dsCCPhos/Development/Data/TestData/CCPTestData.rds")
# Definition of test resource, exemplary with local csv-file
TestResource <- resourcer::newResource(name = "TestResource",
#url = "file://./Development/Test/DummyData.csv",
url = "file://localhost/C:/Users/Basti/ARBEIT Lokal/dsCCPhosClient/Development/Test/DummyData.csv",
format = "csv")
CCPConnections <- ConnectToVirtualCCP(CCPTestData = TestData,
NumberOfServers = 3,
NumberOfPatientsPerServer = 2000,
AddedDsPackages = "dsTidyverse")
Requirements <- CheckServerRequirements()
# Load package namespace. This also registers necessary ResourceResolvers.
library(resourcer)
