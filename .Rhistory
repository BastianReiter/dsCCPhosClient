filter(Site != "All")
Plot <- ggplot(data = as.data.frame(PlotData),
mapping = aes(fill = Site,
x = Value,
y = AbsoluteFrequency)) +
geom_bar(position = "stack",
stat = "identity")
Plot
Plot <- MakeColumnPlot(DataFrame = PlotData,
XFeature = Value,
YFeature = AbsoluteFrequency,
FillPalette = c("SiteA" = CCPhosColors$Primary,
"SiteB" = CCPhosColors$Secondary,
"SiteC" = CCPhosColors$Tertiary))
Plot
Test <- ExploreFeature(DataSources = CCPConnections,
TableName = "ADS_Patients",
FeatureName = "TimeDiagnosisToDeath")
View(Test)
devtools::load_all(".")
library(dsBaseClient)
library(dsCCPhosClient)
#TestData <- readRDS("../dsCCPhos/Development/Data/RealData/CCPRealData_Frankfurt.rds")
TestData <- readRDS("../dsCCPhos/Development/Data/TestData/CCPTestData.rds")
CCPConnections <- ConnectToVirtualCCP(CCPTestData = TestData,
NumberOfSites = 3,
NumberOfPatientsPerSite = 5000)
Messages <- CheckServerRequirements(DataSources = CCPConnections)
Messages <- LoadRawDataSet(CCPSiteSpecifications = NULL,
DataSources = CCPConnections)
# Transform Raw Data Set (RDS) into Curated Data Set (CDS)
Messages <- ds.CurateData(RawDataSetName = "RawDataSet",
OutputName = "CurationOutput",
DataSources = CCPConnections)
# Run ds.AugmentData
Messages <- ds.AugmentData(CuratedDataSetName = "CuratedDataSet",
OutputName = "AugmentationOutput",
DataSources = CCPConnections)
# Make tables from Augmented Data Set directly addressable by unpacking them into R server session
Messages <- ds.UnpackAugmentedDataSet(AugmentedDataSetName = "AugmentedDataSet",
DataSources = CCPConnections)
devtools::load_all(".")
devtools::load_all(".")
devtools::load_all(".")
library(dsBaseClient)
library(dsCCPhosClient)
#TestData <- readRDS("../dsCCPhos/Development/Data/RealData/CCPRealData_Frankfurt.rds")
TestData <- readRDS("../dsCCPhos/Development/Data/TestData/CCPTestData.rds")
CCPConnections <- ConnectToVirtualCCP(CCPTestData = TestData,
NumberOfSites = 3,
NumberOfPatientsPerSite = 5000)
Messages <- CheckServerRequirements(DataSources = CCPConnections)
Messages <- LoadRawDataSet(CCPSiteSpecifications = NULL,
DataSources = CCPConnections)
devtools::load_all(".")
devtools::load_all(".")
Messages <-ds.GetRDSTableCheck(DataSources = CCPConnections)
Messages$SiteA$RDS_Diagnosis
devtools::load_all(".")
library(dsBaseClient)
library(dsCCPhosClient)
#TestData <- readRDS("../dsCCPhos/Development/Data/RealData/CCPRealData_Frankfurt.rds")
TestData <- readRDS("../dsCCPhos/Development/Data/TestData/CCPTestData.rds")
CCPConnections <- ConnectToVirtualCCP(CCPTestData = TestData,
NumberOfSites = 3,
NumberOfPatientsPerSite = 5000)
Messages <- CheckServerRequirements(DataSources = CCPConnections)
Messages <- LoadRawDataSet(CCPSiteSpecifications = NULL,
DataSources = CCPConnections)
# For Testing Purposes
DataSources <- CCPConnections
RawDataSetName <- "RawDataSet"
ServerCall <- call("GetRDSTableCheckDS",
RawDataSetName.S = RawDataSetName)
TableCheck <- DSI::datashield.aggregate(conns = DataSources,
expr = ServerCall)
View(dsCCPhosClient::Meta_ServerRequirements)
View(dsCCPhosClient::Meta_ServerRequirements$RequiredPackages)
View(dsCCPhosClient::Meta_ServerRequirements$RequiredFunctions)
View(dsCCPhosClient::Meta_ServerRequirements$RequiredFunctions)
View(dsCCPhosClient::Meta_ServerRequirements$RequiredPackages)
View(dsCCPhosClient::Meta_ServerRequirements$RequiredFunctions)
View(dsCCPhosClient::Meta_ServerRequirements$RequiredFunctions)
View(dsCCPhosClient::Meta_ServerRequirements$RequiredFunctions)
is.data.frame(dsCCPhosClient::Meta_ServerRequirements$RequiredPackages)
View(data.frame(PackageName = c("ABC", "HFH")))
c(assign = "ABF", aggr = "djk")
devtools::load_all(".")
library(dsBaseClient)
library(dsCCPhosClient)
#TestData <- readRDS("../dsCCPhos/Development/Data/RealData/CCPRealData_Frankfurt.rds")
TestData <- readRDS("../dsCCPhos/Development/Data/TestData/CCPTestData.rds")
CCPConnections <- ConnectToVirtualCCP(CCPTestData = TestData,
NumberOfSites = 3,
NumberOfPatientsPerSite = 5000)
Messages <- CheckServerRequirements(DataSources = CCPConnections)
devtools::load_all(".")
Messages <- CheckServerRequirements(DataSources = CCPConnections)
devtools::load_all(".")
Messages <- CheckServerRequirements(DataSources = CCPConnections)
View(Messages$PackageAvailability)
View(Messages$VersionOfdsCCPhos)
View(Messages$FunctionAvailability)
View(Messages$OpalTableAvailability)
View(Messages$OpalTableAvailability)
View(Messages$FunctionAvailability)
CCPConnections
CCPConnections$SiteA
?datashield.login
View(Messages$PackageAvailability)
Test <- Messages$PackageAvailability
t(Test)
?transpose
Test2 <- as_tibble(cbind(nms = names(Test),))
Test2 <- as_tibble(cbind(nms = names(Test), t(Test)))
View(Test2)
View(Test)
require(dplyr)
require(DSI)
require(tidyr)
# For testing purposes
DataSources <- CCPConnections
RequiredPackages = c("dsBase", "dsCCPhos")
RequiredFunctions = c(aggregate = "GetReportingObjectDS",
assign = "AugmentDataDS",
assign = "CurateDataDS",
assign = "ExtractFromListDS")
# Initiate output messaging objects
Messages <- list()
Messages$PackageAvailability <- c(Topic = "Package availability")
Messages$VersionOfdsCCPhos <- c(Topic = "Version of dsCCPhos")
Messages$FunctionAvailability <- c(Topic = "Function availability")
Messages$TableAvailability <- c(Topic = "Opal DB table availability")
# Get server names (sorted alphabetically)
ServerNames <- sort(names(DataSources))
# Get info about installed server packages
PackageAvailability <- as_tibble(DSI::datashield.pkg_status(conns = DataSources)$package_status,
rownames = "PackageName")
# Check if defined set of packages is available on all servers
RequiredPackageAvailability <- data.frame(PackageName = RequiredPackages) %>%
left_join(PackageAvailability, by = join_by(PackageName)) %>%
rowwise() %>%
mutate(across(all_of(ServerNames), ~ ifelse(is.na(.), FALSE, .)),      # Replace NA values with FALSE. NAs are introduced when a required package is not listed in 'PackageAvailability'.
IsAvailableEverywhere = all(c_across(all_of(ServerNames)) == TRUE),
NotAvailableAt = ifelse(IsAvailableEverywhere == FALSE,
paste0(ServerNames[c_across(all_of(ServerNames)) == FALSE], collapse = ", "),
NA)) %>%
ungroup()
?pivot_wider
RequiredPackageAvailability <- RequiredPackageAvailability %>%
select(-IsAvailableEverywhere,
-NotAvailableAt) %>%
pivot_wider(names_from = PackageName,
values_from = c(SiteA, SiteB, SiteC))
View(RequiredPackageAvailability)
# Check if defined set of packages is available on all servers
RequiredPackageAvailability <- data.frame(PackageName = RequiredPackages) %>%
left_join(PackageAvailability, by = join_by(PackageName)) %>%
rowwise() %>%
mutate(across(all_of(ServerNames), ~ ifelse(is.na(.), FALSE, .)),      # Replace NA values with FALSE. NAs are introduced when a required package is not listed in 'PackageAvailability'.
IsAvailableEverywhere = all(c_across(all_of(ServerNames)) == TRUE),
NotAvailableAt = ifelse(IsAvailableEverywhere == FALSE,
paste0(ServerNames[c_across(all_of(ServerNames)) == FALSE], collapse = ", "),
NA)) %>%
ungroup()
RequiredPackageAvailabilityW <- RequiredPackageAvailability %>%
select(-IsAvailableEverywhere,
-NotAvailableAt) %>%
tibble::rownames_to_column()
View(RequiredPackageAvailabilityW)
RequiredPackageAvailabilityW <- RequiredPackageAvailability %>%
select(-IsAvailableEverywhere,
-NotAvailableAt) %>%
tibble::rownames_to_column() %>%
pivot_longer(-rowname)
View(RequiredPackageAvailabilityW)
?pivot_longer
RequiredPackageAvailabilityW <- RequiredPackageAvailability %>%
select(-IsAvailableEverywhere,
-NotAvailableAt) %>%
#tibble::rownames_to_column() %>%
pivot_longer(names_to = "SiteName",
values_to = "Test")
RequiredPackageAvailabilityW <- RequiredPackageAvailability %>%
select(-IsAvailableEverywhere,
-NotAvailableAt) %>%
#tibble::rownames_to_column() %>%
pivot_longer(!PackageName,
names_to = "SiteName",
values_to = "Test")
View(RequiredPackageAvailabilityW)
RequiredPackageAvailabilityW <- RequiredPackageAvailability %>%
select(-IsAvailableEverywhere,
-NotAvailableAt) %>%
#tibble::rownames_to_column() %>%
pivot_longer(!PackageName,
names_to = "SiteName",
values_to = "Test") %>%
pivot_wider(names_from = PackageName,
values_from = Test)
View(RequiredPackageAvailabilityW)
View(RequiredPackageAvailabilityW)
RequiredPackageAvailabilityW <- RequiredPackageAvailability %>%
select(-IsAvailableEverywhere,
-NotAvailableAt) %>%
pivot_longer(!PackageName,
names_to = "SiteName",
values_to = "IsAvailable") %>%
pivot_wider(names_from = PackageName,
values_from = IsAvailable)
View(RequiredPackageAvailabilityW)
# Get version number of dsCCPhos on all servers and check for equality
VersionOfdsCCPhos <- as_tibble(DSI::datashield.pkg_status(conns = DataSources)$version_status,
rownames = "PackageName") %>%
filter(PackageName == "dsCCPhos") %>%
select(-PackageName)
View(VersionOfdsCCPhos)
# Transform / Transpose data frame for more useful return info
VersionOfdsCCPhos <- VersionOfdsCCPhos %>%
pivot_longer(everything(),
names_to = "SiteName",
values_to = "IsAvailable")
View(VersionOfdsCCPhos)
View(RequiredPackageAvailabilityW)
# Get version number of dsCCPhos on all servers and check for equality
VersionOfdsCCPhos <- as_tibble(DSI::datashield.pkg_status(conns = DataSources)$version_status,
rownames = "PackageName") %>%
filter(PackageName == "dsCCPhos") %>%
select(-PackageName)
# Transform / Transpose data frame for more useful return info
VersionOfdsCCPhos <- VersionOfdsCCPhos %>%
pivot_longer(everything(),
names_to = "SiteName",
values_to = "dsCCPhosVersion")
# Get coherent data frame of general function availability on all servers
FunctionAvailability <- rbind(# Get data frame of available AGGREGATE functions
DSI::datashield.method_status(conns = DataSources,
type = "aggregate"),
# Get data frame of available ASSIGN functions
DSI::datashield.method_status(conns = DataSources,
type = "assign"))
# Check if defined set of required functions is available on all servers
RequiredFunctionAvailability <- data.frame(FunctionName = RequiredFunctions,
FunctionType = names(RequiredFunctions)) %>%
left_join(FunctionAvailability, by = join_by(FunctionName == name, FunctionType == type)) %>%
rowwise() %>%
mutate(across(ServerNames, ~ ifelse(is.na(.), FALSE, .)),      # Replace NA values with FALSE. NAs are introduced when a required function is not listed in 'FunctionAvailability'.
IsAvailableEverywhere = all(c_across(all_of(ServerNames)) == TRUE),
NotAvailableAt = ifelse(IsAvailableEverywhere == FALSE,
paste0(ServerNames[c_across(all_of(ServerNames)) == FALSE], collapse = ", "),
NA)) %>%
ungroup()
# Get coherent data frame of general function availability on all servers
FunctionAvailability <- rbind(# Get data frame of available AGGREGATE functions
DSI::datashield.method_status(conns = DataSources,
type = "aggregate"),
# Get data frame of available ASSIGN functions
DSI::datashield.method_status(conns = DataSources,
type = "assign"))
# Check if defined set of required functions is available on all servers
RequiredFunctionAvailability <- data.frame(FunctionName = RequiredFunctions,
FunctionType = names(RequiredFunctions)) %>%
left_join(FunctionAvailability, by = join_by(FunctionName == name, FunctionType == type)) %>%
rowwise() %>%
mutate(across(all_of(ServerNames), ~ ifelse(is.na(.), FALSE, .)),      # Replace NA values with FALSE. NAs are introduced when a required function is not listed in 'FunctionAvailability'.
IsAvailableEverywhere = all(c_across(all_of(ServerNames)) == TRUE),
NotAvailableAt = ifelse(IsAvailableEverywhere == FALSE,
paste0(ServerNames[c_across(all_of(ServerNames)) == FALSE], collapse = ", "),
NA)) %>%
ungroup()
View(RequiredFunctionAvailability)
# Transform / Transpose data frame into more handy return object
RequiredFunctionAvailabilityW <- RequiredFunctionAvailability %>%
select(-IsAvailableEverywhere,
-NotAvailableAt) %>%
pivot_longer(!FunctionName,
names_to = "SiteName",
values_to = "IsAvailable") %>%
pivot_wider(names_from = FunctionName,
values_from = IsAvailable)
# Transform / Transpose data frame into more handy return object
RequiredFunctionAvailabilityW <- RequiredFunctionAvailability %>%
select(-FunctionType,
-IsAvailableEverywhere,
-NotAvailableAt) %>%
pivot_longer(everythingFunctionName,
names_to = "SiteName",
values_to = "IsAvailable") %>%
pivot_wider(names_from = FunctionName,
values_from = IsAvailable)
# Transform / Transpose data frame into more handy return object
RequiredFunctionAvailabilityW <- RequiredFunctionAvailability %>%
select(-FunctionType,
-IsAvailableEverywhere,
-NotAvailableAt) %>%
pivot_longer(!FunctionName,
names_to = "SiteName",
values_to = "IsAvailable") %>%
pivot_wider(names_from = FunctionName,
values_from = IsAvailable)
View(RequiredFunctionAvailabilityW)
# Get info on Opal table availability with dsCCPhosClient::GetServerOpalDBInfo()
RequiredTableAvailability <- GetServerOpalInfo(CCPSiteSpecifications,
DataSources)
View(RequiredTableAvailability)
# Transform / Transpose data frame into more handy return object
RequiredTableAvailabilityW <- RequiredTableAvailability %>%
select(-IsAvailableEverywhere,
-NotAvailableAt) %>%
pivot_longer(!TableName,
names_to = "SiteName",
values_to = "IsAvailable") %>%
pivot_wider(names_from = TableName,
values_from = IsAvailable)
View(RequiredTableAvailabilityW)
# Get info about installed server packages
PackageAvailability <- as_tibble(DSI::datashield.pkg_status(conns = DataSources)$package_status,
rownames = "PackageName")
# Check if defined set of packages is available on all servers
RequiredPackageAvailability <- data.frame(PackageName = RequiredPackages) %>%
left_join(PackageAvailability, by = join_by(PackageName)) %>%
rowwise() %>%
mutate(across(all_of(ServerNames), ~ ifelse(is.na(.), FALSE, .)),      # Replace NA values with FALSE. NAs are introduced when a required package is not listed in 'PackageAvailability'.
IsAvailableEverywhere = all(c_across(all_of(ServerNames)) == TRUE),
NotAvailableAt = ifelse(IsAvailableEverywhere == FALSE,
paste0(ServerNames[c_across(all_of(ServerNames)) == FALSE], collapse = ", "),
NA)) %>%
ungroup()
View(RequiredPackageAvailability)
# Transform / Transpose data frame into more handy return object
RequiredPackageAvailabilityW <- RequiredPackageAvailability %>%
select(-IsAvailableEverywhere,
-NotAvailableAt) %>%
pivot_longer(!PackageName,
names_to = "SiteName",
values_to = "IsAvailable") %>%
pivot_wider(names_from = PackageName,
values_from = IsAvailable)
View(PackageAvailability)
View(RequiredPackageAvailabilityW)
# Transform / Transpose data frame into more handy return object
RequiredPackageAvailabilityW <- RequiredPackageAvailability %>%
select(-IsAvailableEverywhere,
-NotAvailableAt) %>%
pivot_longer(!PackageName,
names_to = "SiteName",
values_to = "IsAvailable") %>%
pivot_wider(names_from = PackageName,
values_from = IsAvailable) %>%
mutate(SiteCheck = case_when(all(everything(-PackageName) == TRUE) ~ "green",
TRUE ~ "red"))
# Transform / Transpose data frame into more handy return object
RequiredPackageAvailabilityW <- RequiredPackageAvailability %>%
select(-IsAvailableEverywhere,
-NotAvailableAt) %>%
pivot_longer(!PackageName,
names_to = "SiteName",
values_to = "IsAvailable") %>%
pivot_wider(names_from = PackageName,
values_from = IsAvailable) %>%
mutate(SiteCheck = case_when(all(-PackageName) == TRUE ~ "green",
TRUE ~ "red"))
# Transform / Transpose data frame into more handy return object
RequiredPackageAvailabilityW <- RequiredPackageAvailability %>%
select(-IsAvailableEverywhere,
-NotAvailableAt) %>%
pivot_longer(!PackageName,
names_to = "SiteName",
values_to = "IsAvailable") %>%
pivot_wider(names_from = PackageName,
values_from = IsAvailable) %>%
mutate(SiteCheck = case_when(all(-SiteName) == TRUE ~ "green",
TRUE ~ "red"))
# Transform / Transpose data frame into more handy return object
RequiredPackageAvailabilityW <- RequiredPackageAvailability %>%
select(-IsAvailableEverywhere,
-NotAvailableAt) %>%
pivot_longer(!PackageName,
names_to = "SiteName",
values_to = "IsAvailable") %>%
pivot_wider(names_from = PackageName,
values_from = IsAvailable) %>%
mutate(SiteCheck = case_when(everything(-SiteName) == TRUE ~ "green",
TRUE ~ "red"))
# Transform / Transpose data frame into more handy return object
RequiredPackageAvailabilityW <- RequiredPackageAvailability %>%
select(-IsAvailableEverywhere,
-NotAvailableAt) %>%
pivot_longer(!PackageName,
names_to = "SiteName",
values_to = "IsAvailable") %>%
pivot_wider(names_from = PackageName,
values_from = IsAvailable) %>%
mutate(SiteCheck = case_when(all(everything(-SiteName)) == TRUE ~ "green",
TRUE ~ "red"))
# Transform / Transpose data frame into more handy return object
RequiredPackageAvailabilityW <- RequiredPackageAvailability %>%
select(-IsAvailableEverywhere,
-NotAvailableAt) %>%
pivot_longer(!PackageName,
names_to = "SiteName",
values_to = "IsAvailable") %>%
pivot_wider(names_from = PackageName,
values_from = IsAvailable) %>%
mutate(SiteCheck = case_when(all_of(everything(), -PackageName) == TRUE ~ "green",
TRUE ~ "red"))
# Transform / Transpose data frame into more handy return object
RequiredPackageAvailabilityW <- RequiredPackageAvailability %>%
select(-IsAvailableEverywhere,
-NotAvailableAt) %>%
pivot_longer(!PackageName,
names_to = "SiteName",
values_to = "IsAvailable") %>%
pivot_wider(names_from = PackageName,
values_from = IsAvailable) %>%
mutate(SiteCheck = case_when(all_of(everything(), -SiteName) == TRUE ~ "green",
TRUE ~ "red"))
# Transform / Transpose data frame into more handy return object
RequiredPackageAvailabilityW <- RequiredPackageAvailability %>%
select(-IsAvailableEverywhere,
-NotAvailableAt) %>%
pivot_longer(!PackageName,
names_to = "SiteName",
values_to = "IsAvailable") %>%
pivot_wider(names_from = PackageName,
values_from = IsAvailable) %>%
mutate(SiteCheck = case_when(across(-SiteName) == TRUE ~ "green",
TRUE ~ "red"))
# Transform / Transpose data frame into more handy return object
RequiredPackageAvailabilityW <- RequiredPackageAvailability %>%
select(-IsAvailableEverywhere,
-NotAvailableAt) %>%
pivot_longer(!PackageName,
names_to = "SiteName",
values_to = "IsAvailable") %>%
pivot_wider(names_from = PackageName,
values_from = IsAvailable) %>%
mutate(SiteCheck = case_when(c_across(-SiteName) == TRUE ~ "green",
TRUE ~ "red"))
?if_all
# Transform / Transpose data frame into more handy return object
RequiredPackageAvailabilityW <- RequiredPackageAvailability %>%
select(-IsAvailableEverywhere,
-NotAvailableAt) %>%
pivot_longer(!PackageName,
names_to = "SiteName",
values_to = "IsAvailable") %>%
pivot_wider(names_from = PackageName,
values_from = IsAvailable) %>%
mutate(SiteCheck = case_when(c_across(-SiteName) == TRUE ~ "green",
TRUE ~ "red"))
# Transform / Transpose data frame into more handy return object
RequiredPackageAvailabilityW <- RequiredPackageAvailability %>%
select(-IsAvailableEverywhere,
-NotAvailableAt) %>%
pivot_longer(!PackageName,
names_to = "SiteName",
values_to = "IsAvailable") %>%
pivot_wider(names_from = PackageName,
values_from = IsAvailable) %>%
mutate(SiteCheck = if_all(-SiteName, ~ .x == TRUE))
View(RequiredPackageAvailabilityW)
# Transform / Transpose data frame into more handy return object
RequiredPackageAvailabilityW <- RequiredPackageAvailability %>%
select(-IsAvailableEverywhere,
-NotAvailableAt) %>%
pivot_longer(!PackageName,
names_to = "SiteName",
values_to = "IsAvailable") %>%
pivot_wider(names_from = PackageName,
values_from = IsAvailable) %>%
mutate(SiteCheck = case_when(if_all(-SiteName, ~ .x == TRUE) ~ "green",
TRUE ~ "red"))
# Check if defined set of required functions is available on all servers
RequiredFunctionAvailability <- data.frame(FunctionName = RequiredFunctions,
FunctionType = names(RequiredFunctions)) %>%
left_join(FunctionAvailability, by = join_by(FunctionName == name, FunctionType == type)) %>%
rowwise() %>%
mutate(across(all_of(ServerNames), ~ ifelse(is.na(.), FALSE, .)),      # Replace NA values with FALSE. NAs are introduced when a required function is not listed in 'FunctionAvailability'.
IsAvailableEverywhere = all(c_across(all_of(ServerNames)) == TRUE),
NotAvailableAt = ifelse(IsAvailableEverywhere == FALSE,
paste0(ServerNames[c_across(all_of(ServerNames)) == FALSE], collapse = ", "),
NA)) %>%
ungroup()
# Transform / Transpose data frame into more handy return object
RequiredFunctionAvailability <- RequiredFunctionAvailability %>%
select(-FunctionType,
-IsAvailableEverywhere,
-NotAvailableAt) %>%
pivot_longer(!FunctionName,
names_to = "SiteName",
values_to = "IsAvailable") %>%
pivot_wider(names_from = FunctionName,
values_from = IsAvailable) %>%
mutate(SiteCheck = case_when(if_all(-SiteName, ~ .x == TRUE) ~ "green",
TRUE ~ "red"))
View(RequiredFunctionAvailability)
# Get info on Opal table availability with dsCCPhosClient::GetServerOpalDBInfo()
RequiredTableAvailability <- GetServerOpalInfo(CCPSiteSpecifications,
DataSources)
# Transform / Transpose data frame into more handy return object
RequiredTableAvailability <- RequiredTableAvailability %>%
select(-IsAvailableEverywhere,
-NotAvailableAt) %>%
pivot_longer(!TableName,
names_to = "SiteName",
values_to = "IsAvailable") %>%
pivot_wider(names_from = TableName,
values_from = IsAvailable) %>%
mutate(SiteCheck = case_when(if_all(-SiteName, ~ .x == TRUE) ~ "green",
TRUE ~ "red"))
View(RequiredTableAvailability)
