devtools::load_all(".")
library(dsBaseClient)
library(dsFredaClient)
library(dsTidyverseClient)
library(resourcer)
# Print DataSHIELD errors right away
options(datashield.errors.print = TRUE)
#TestData <- readRDS("../dsCCPhos/Development/Data/RealData/CCPRealData_Frankfurt.rds")
TestData <- readRDS("../dsCCPhos/Development/Data/TestData/CCPTestData.rds")
# Definition of test resource, exemplary with local csv-file
TestResource <- resourcer::newResource(name = "TestResource",
#url = "file://./Development/Test/DummyData.csv",
url = "file://localhost/C:/Users/Basti/ARBEIT Lokal/dsCCPhosClient/Development/Test/DummyData.csv",
format = "csv")
CCPConnections <- ConnectToVirtualCCP(CCPTestData = TestData,
NumberOfServers = 3,
NumberOfPatientsPerServer = 2000,
AddedDsPackages = "dsTidyverse",
Resources = list(TestResource = TestResource))
CheckServerRequirements()
?pluck
DSConnections <- CCPConnections
RequiredPackages = c("dsBase", "dsCCPhos")
RequiredFunctions = c(aggregate = "GetReportingObjectDS",
assign = "AugmentDataDS",
assign = "CurateDataDS",
assign = "ExtractFromListDS")
# Initiate output messaging objects
Messages <- list()
Messages$PackageAvailability <- c(Topic = "Package availability")
Messages$VersionOfdsCCPhos <- c(Topic = "Version of dsCCPhos")
Messages$FunctionAvailability <- c(Topic = "Function availability")
Messages$TableAvailability <- c(Topic = "Opal DB table availability")
# Get server names (sorted alphabetically)
ServerNames <- sort(names(DSConnections))
# Get info about installed server packages
PackageAvailability <- as_tibble(DSI::datashield.pkg_status(conns = DSConnections)$package_status,
rownames = "PackageName")
# Check if defined set of packages is available on all servers
RequiredPackageAvailability <- tibble(PackageName = RequiredPackages) %>%
left_join(PackageAvailability, by = join_by(PackageName)) %>%
rowwise() %>%
mutate(across(all_of(ServerNames), ~ ifelse(is.na(.), FALSE, .)),      # Replace NA values with FALSE. NAs are introduced when a required package is not listed in 'PackageAvailability'.
IsAvailableEverywhere = all(c_across(all_of(ServerNames)) == TRUE),
NotAvailableAt = ifelse(IsAvailableEverywhere == FALSE,
paste0(ServerNames[c_across(all_of(ServerNames)) == FALSE], collapse = ", "),
NA)) %>%
ungroup()
# Compile output message concerning one package each and add it to Messages
for (i in 1:nrow(RequiredPackageAvailability))
{
Row <- RequiredPackageAvailability[i, ]
# Note: It's important to use 'dplyr::if_else()' instead of 'ifelse' here, otherwise the return won't be a named vector
Message <- if_else(Row$IsAvailableEverywhere == TRUE,
MakeFunctionMessage(Text = paste0("Function '",
Row$PackageName,
"' is available on all servers!"),
IsClassSuccess = TRUE),
MakeFunctionMessage(Text = paste0("Package '",
Row$PackageName,
"' is not available at ",
Row$NotAvailableAt),
IsClassFailure = TRUE))
Messages$PackageAvailability <- c(Messages$PackageAvailability,
Message)
}
# Transform / Transpose data frame into more handy return object
RequiredPackageAvailability <- RequiredPackageAvailability %>%
select(-IsAvailableEverywhere,
-NotAvailableAt) %>%
pivot_longer(!PackageName,
names_to = "ServerName",
values_to = "IsAvailable") %>%
pivot_wider(names_from = PackageName,
values_from = IsAvailable) %>%
mutate(CheckPackageAvailability = case_when(if_all(-ServerName, ~ .x == TRUE) ~ "green",
TRUE ~ "red"))
# Get version number of dsCCPhos on all servers and check for equality
VersionOfdsCCPhos <- as_tibble(DSI::datashield.pkg_status(conns = DSConnections)$version_status,
rownames = "PackageName") %>%
filter(PackageName == "dsCCPhos") %>%
select(-PackageName)
if (nrow(VersionOfdsCCPhos > 0))
{
IsEqualEverywhere <- apply(VersionOfdsCCPhos, 1, function(Values) { all(Values == Values[1]) })
MessageOverall <- NULL
MessagesDetail <- NULL
if (IsEqualEverywhere == TRUE)
{
MessageOverall <- MakeFunctionMessage(Text = paste0("Version of dsCCPhos is equal on all servers (Ver. ", VersionOfdsCCPhos[1, 1], ")!"),
IsClassSuccess = TRUE)
}
else
{
MessagesOverall <- MakeFunctionMessage(Text = paste0("Version of dsCCPhos varies between servers!"),
IsClassWarning = TRUE)
for (i in 1:ncol(VersionOfdsCCPhos))
{
MessagesDetail <- c(Messages$VersionOfdsCCPhos,
MakeFunctionMessage(Text = paste0(names(VersionOfdsCCPhos)[i], ": Ver. ", VersionOfdsCCPhos[, i]),
IsClassInfo = TRUE))
}
}
Messages$VersionOfdsCCPhos <- c(Messages$VersionOfdsCCPhos,
MessageOverall,
MessagesDetail)
}
# Transform / Transpose data frame into more handy return object
VersionOfdsCCPhos <- VersionOfdsCCPhos %>%
pivot_longer(everything(),
names_to = "ServerName",
values_to = "dsCCPhosVersion")
# Get coherent data frame of general function availability on all servers
FunctionAvailability <- rbind(# Get data frame of available AGGREGATE functions
DSI::datashield.method_status(conns = DSConnections,
type = "aggregate"),
# Get data frame of available ASSIGN functions
DSI::datashield.method_status(conns = DSConnections,
type = "assign"))
# Check if defined set of required functions is available on all servers
RequiredFunctionAvailability <- data.frame(FunctionName = RequiredFunctions,
FunctionType = names(RequiredFunctions)) %>%
left_join(FunctionAvailability, by = join_by(FunctionName == name, FunctionType == type)) %>%
rowwise() %>%
mutate(across(all_of(ServerNames), ~ ifelse(is.na(.), FALSE, .)),      # Replace NA values with FALSE. NAs are introduced when a required function is not listed in 'FunctionAvailability'.
IsAvailableEverywhere = all(c_across(all_of(ServerNames)) == TRUE),
NotAvailableAt = ifelse(IsAvailableEverywhere == FALSE,
paste0(ServerNames[c_across(all_of(ServerNames)) == FALSE], collapse = ", "),
NA)) %>%
ungroup()
# Compile output message concerning one function each and add it to Messages
for (i in 1:nrow(RequiredFunctionAvailability))
{
Row <- RequiredFunctionAvailability[i, ]
# Note: It's important to use 'dplyr::if_else()' instead of 'ifelse' here, otherwise the return won't be a named vector
Message <- if_else(Row$IsAvailableEverywhere == TRUE,
MakeFunctionMessage(Text = paste0("Function '",
Row$FunctionName,
"' is available on all servers!"),
IsClassSuccess = TRUE),
MakeFunctionMessage(Text = paste0("Function '",
Row$FunctionName,
"' is not available at ",
Row$NotAvailableAt),
IsClassWarning = TRUE))
Messages$FunctionAvailability <- c(Messages$FunctionAvailability,
Message)
}
# Transform / Transpose data frame into more handy return object
RequiredFunctionAvailability <- RequiredFunctionAvailability %>%
select(-FunctionType,
-IsAvailableEverywhere,
-NotAvailableAt) %>%
pivot_longer(!FunctionName,
names_to = "ServerName",
values_to = "IsAvailable") %>%
pivot_wider(names_from = FunctionName,
values_from = IsAvailable) %>%
mutate(CheckFunctionAvailability = case_when(if_all(-ServerName, ~ .x == TRUE) ~ "green",
TRUE ~ "red"))
# Get info on Opal table availability with dsCCPhosClient::GetServerOpalDBInfo()
RequiredOpalTableAvailability <- dsFredaClient::GetServerOpalDBInfo(ServerSpecifications,
RequiredTableNames = RequiredOpalTableNames,
DSConnections)
?dsFredaClient::GetServerOpalDBInfo
# Get info on Opal table availability with dsCCPhosClient::GetServerOpalDBInfo()
RequiredOpalTableAvailability <- dsFredaClient::GetServerOpalDBInfo(ServerSpecifications,
OpalTableNames.Required = RequiredOpalTableNames,
DSConnections)
# --- For Testing Purposes ---
# DSConnections <- CCPConnections
# RequiredPackages = c("dsBase", "dsCCPhos")
# RequiredFunctions = c(aggregate = "GetReportingObjectDS",
#                       assign = "AugmentDataDS",
#                       assign = "CurateDataDS",
#                       assign = "ExtractFromListDS")
RequiredOpalTableNames = dsCCPhosClient::Meta.Tables$TableName.Raw
# Get info on Opal table availability with dsCCPhosClient::GetServerOpalDBInfo()
RequiredOpalTableAvailability <- dsFredaClient::GetServerOpalDBInfo(ServerSpecifications,
OpalTableNames.Required = RequiredOpalTableNames,
DSConnections)
# Get info on Opal table availability with dsCCPhosClient::GetServerOpalDBInfo()
RequiredOpalTableAvailability <- dsFredaClient::GetServerOpalDBInfo(ServerSpecifications = ServerSpecifications,
OpalTableNames.Required = RequiredOpalTableNames,
OpalTableNames.Dictionary = NULL,
DSConnections = DSConnections)
# Get info on Opal table availability with dsCCPhosClient::GetServerOpalDBInfo()
RequiredOpalTableAvailability <- dsFredaClient::GetServerOpalDBInfo(ServerSpecifications = ServerSpecifications,
OpalTableNames.Required = RequiredOpalTableNames,
OpalTableNames.Dictionary = NULL,
DSConnections = DSConnections) %>%
pluck("OpalTableAvailability.Requirements")
# Compile output message concerning one table each and add it to Messages
for (i in 1:nrow(RequiredOpalTableAvailability))
{
Row <- RequiredOpalTableAvailability[i, ]
# Note: It's important to use 'dplyr::if_else()' instead of 'ifelse' here, otherwise the return won't be a named vector
Message <- if_else(Row$IsAvailableEverywhere == TRUE,
MakeFunctionMessage(Text = paste0("Opal data base table '",
Row$TableName,
"' is available on all servers!"),
IsClassSuccess = TRUE),
MakeFunctionMessage(Text = paste0("Opal data base table '",
Row$TableName,
"' is not available at ",
Row$NotAvailableAt),
IsClassWarning = TRUE))
Messages$TableAvailability <- c(Messages$TableAvailability,
Message)
}
# Transform / Transpose data frame into more handy return object
RequiredOpalTableAvailability <- RequiredOpalTableAvailability %>%
select(-IsAvailableEverywhere,
-NotAvailableAt) %>%
pivot_longer(!TableName,
names_to = "ServerName",
values_to = "IsAvailable") %>%
pivot_wider(names_from = TableName,
values_from = IsAvailable) %>%
mutate(CheckOpalTableAvailability = case_when(if_all(-ServerName, ~ .x == TRUE) ~ "green",
TRUE ~ "red"))
View(Row)
View(RequiredOpalTableAvailability)
devtools::load_all(".")
library(dsBaseClient)
library(dsFredaClient)
library(dsTidyverseClient)
library(resourcer)
# Print DataSHIELD errors right away
options(datashield.errors.print = TRUE)
#TestData <- readRDS("../dsCCPhos/Development/Data/RealData/CCPRealData_Frankfurt.rds")
TestData <- readRDS("../dsCCPhos/Development/Data/TestData/CCPTestData.rds")
# Definition of test resource, exemplary with local csv-file
TestResource <- resourcer::newResource(name = "TestResource",
#url = "file://./Development/Test/DummyData.csv",
url = "file://localhost/C:/Users/Basti/ARBEIT Lokal/dsCCPhosClient/Development/Test/DummyData.csv",
format = "csv")
CCPConnections <- ConnectToVirtualCCP(CCPTestData = TestData,
NumberOfServers = 3,
NumberOfPatientsPerServer = 2000,
AddedDsPackages = "dsTidyverse",
Resources = list(TestResource = TestResource))
# --- For Testing Purposes ---
ServerSpecifications <- NULL
OpalTableNames.Mapping = setNames(dsCCPhosClient::Meta.Tables$TableName.Curated,
nm = dsCCPhosClient::Meta.Tables$TableName.Raw)
OpalTableNames.Dictionary = NULL
DSConnections <- CCPConnections
RunAssignmentChecks <- TRUE
# Initiate output messaging objects
Messages <- list()
if (RunAssignmentChecks == TRUE) { Messages$Assignment <- c(Topic = "Object assignment on servers") }
# Get server names
ServerNames <- names(DSConnections)
# Check Opal table availability
OpalTableAvailability <- dsFredaClient::GetServerOpalDBInfo(ServerSpecifications = ServerSpecifications,
OpalTableNames.Required = names(OpalTableNames.Mapping),
OpalTableNames.Dictionary = OpalTableNames.Dictionary,
DSConnections = DSConnections)
OpalTableAvailability$OpalTableAvailability
i <- 1
OpalDBToR <- OpalTableAvailability$OpalTableAvailability %>%
filter(Server == ServerNames[i],
IsAvailable == TRUE,
IsRequired == TRUE) %>%
mutate(TableName = case_when(OpalTableName.Generic %in% names(OpalTableNames.Mapping) ~ paste0("RDS.", OpalTableNames.Mapping[OpalTableName.Generic]),
.default = paste0("RDS.", OpalTableName.Generic)))
View(OpalDBToR)
OpalDBToR <- OpalTableAvailability$OpalTableAvailability %>%
filter(Server == ServerNames[i],
IsAvailable == TRUE,
IsRequired == TRUE) %>%
mutate(RTableName = case_when(OpalTableName.Generic %in% names(OpalTableNames.Mapping) ~ paste0("RDS.", OpalTableNames.Mapping[OpalTableName.Generic]),
.default = paste0("RDS.", OpalTableName.Generic)))
?DSI::datashield.assign
OpalTableNames.Mapping
devtools::load_all(".")
LoadRawDataSet(ServerSpecifications = NULL)
rm(list=ls())
#TestData <- readRDS("../dsCCPhos/Development/Data/RealData/CCPRealData_Frankfurt.rds")
TestData <- readRDS("../dsCCPhos/Development/Data/TestData/CCPTestData.rds")
# Definition of test resource, exemplary with local csv-file
TestResource <- resourcer::newResource(name = "TestResource",
#url = "file://./Development/Test/DummyData.csv",
url = "file://localhost/C:/Users/Basti/ARBEIT Lokal/dsCCPhosClient/Development/Test/DummyData.csv",
format = "csv")
CCPConnections <- ConnectToVirtualCCP(CCPTestData = TestData,
NumberOfServers = 3,
NumberOfPatientsPerServer = 2000,
AddedDsPackages = "dsTidyverse",
Resources = list(TestResource = TestResource))
CheckServerRequirements()
LoadRawDataSet(ServerSpecifications = NULL)
devtools::load_all(".")
library(dsBaseClient)
library(dsFredaClient)
library(dsTidyverseClient)
library(resourcer)
# Print DataSHIELD errors right away
options(datashield.errors.print = TRUE)
#TestData <- readRDS("../dsCCPhos/Development/Data/RealData/CCPRealData_Frankfurt.rds")
TestData <- readRDS("../dsCCPhos/Development/Data/TestData/CCPTestData.rds")
# Definition of test resource, exemplary with local csv-file
TestResource <- resourcer::newResource(name = "TestResource",
#url = "file://./Development/Test/DummyData.csv",
url = "file://localhost/C:/Users/Basti/ARBEIT Lokal/dsCCPhosClient/Development/Test/DummyData.csv",
format = "csv")
CCPConnections <- ConnectToVirtualCCP(CCPTestData = TestData,
NumberOfServers = 3,
NumberOfPatientsPerServer = 2000,
AddedDsPackages = "dsTidyverse",
Resources = list(TestResource = TestResource))
CheckServerRequirements()
LoadRawDataSet(ServerSpecifications = NULL)
RDSTableCheck <- ds.GetDataSetCheck(DataSetName = "RawDataSet",
Stage = "Raw")
ds.DrawSample(RawDataSetName = "RawDataSet",
SampleSize = 2000,
SampleName = "RDSSample")
# Transform Raw Data Set (RDS) into Curated Data Set (CDS) (using default settings)
ds.CurateData(RawDataSetName = "RawDataSet",
Settings = NULL,
OutputName = "CurationOutput")
CDSTableCheck <- ds.GetDataSetCheck(DataSetName = "CuratedDataSet",
Stage = "Curated")
# Get curation reports
CurationReport <- ds.GetCurationReport()
# Run ds.AugmentData
ds.AugmentData(CuratedDataSetName = "CuratedDataSet",
OutputName = "AugmentationOutput")
devtools::load_all(".")
devtools::load_all(".")
library(dsBaseClient)
library(dsFredaClient)
library(dsTidyverseClient)
library(resourcer)
# Print DataSHIELD errors right away
options(datashield.errors.print = TRUE)
#TestData <- readRDS("../dsCCPhos/Development/Data/RealData/CCPRealData_Frankfurt.rds")
TestData <- readRDS("../dsCCPhos/Development/Data/TestData/CCPTestData.rds")
# Definition of test resource, exemplary with local csv-file
TestResource <- resourcer::newResource(name = "TestResource",
#url = "file://./Development/Test/DummyData.csv",
url = "file://localhost/C:/Users/Basti/ARBEIT Lokal/dsCCPhosClient/Development/Test/DummyData.csv",
format = "csv")
CCPConnections <- ConnectToVirtualCCP(CCPTestData = TestData,
NumberOfServers = 3,
NumberOfPatientsPerServer = 2000,
AddedDsPackages = "dsTidyverse",
Resources = list(TestResource = TestResource))
CheckServerRequirements()
LoadRawDataSet(ServerSpecifications = NULL)
devtools::load_all(".")
library(dsBaseClient)
library(dsFredaClient)
library(dsTidyverseClient)
library(resourcer)
# Print DataSHIELD errors right away
options(datashield.errors.print = TRUE)
#TestData <- readRDS("../dsCCPhos/Development/Data/RealData/CCPRealData_Frankfurt.rds")
TestData <- readRDS("../dsCCPhos/Development/Data/TestData/CCPTestData.rds")
# Definition of test resource, exemplary with local csv-file
TestResource <- resourcer::newResource(name = "TestResource",
#url = "file://./Development/Test/DummyData.csv",
url = "file://localhost/C:/Users/Basti/ARBEIT Lokal/dsCCPhosClient/Development/Test/DummyData.csv",
format = "csv")
CCPConnections <- ConnectToVirtualCCP(CCPTestData = TestData,
NumberOfServers = 3,
NumberOfPatientsPerServer = 2000,
AddedDsPackages = "dsTidyverse",
Resources = list(TestResource = TestResource))
CheckServerRequirements()
LoadRawDataSet(ServerSpecifications = NULL)
RDSTableCheck <- ds.GetDataSetCheck(DataSetName = "RawDataSet",
Stage = "Raw")
devtools::load_all(".")
LoadRawDataSet(ServerSpecifications = NULL)
devtools::load_all(".")
LoadRawDataSet(ServerSpecifications = NULL)
devtools::load_all(".")
devtools::load_all(".")
LoadRawDataSet(ServerSpecifications = NULL)
devtools::load_all(".")
library(dsBaseClient)
library(dsFredaClient)
library(dsTidyverseClient)
library(resourcer)
# Print DataSHIELD errors right away
options(datashield.errors.print = TRUE)
#TestData <- readRDS("../dsCCPhos/Development/Data/RealData/CCPRealData_Frankfurt.rds")
TestData <- readRDS("../dsCCPhos/Development/Data/TestData/CCPTestData.rds")
# Definition of test resource, exemplary with local csv-file
TestResource <- resourcer::newResource(name = "TestResource",
#url = "file://./Development/Test/DummyData.csv",
url = "file://localhost/C:/Users/Basti/ARBEIT Lokal/dsCCPhosClient/Development/Test/DummyData.csv",
format = "csv")
CCPConnections <- ConnectToVirtualCCP(CCPTestData = TestData,
NumberOfServers = 3,
NumberOfPatientsPerServer = 2000,
AddedDsPackages = "dsTidyverse",
Resources = list(TestResource = TestResource))
CheckServerRequirements()
LoadRawDataSet(ServerSpecifications = NULL)
RDSTableCheck <- ds.GetDataSetCheck(DataSetName = "RawDataSet",
Stage = "Raw")
ds.DrawSample(RawDataSetName = "RawDataSet",
SampleSize = 2000,
SampleName = "RDSSample")
# Transform Raw Data Set (RDS) into Curated Data Set (CDS) (using default settings)
ds.CurateData(RawDataSetName = "RawDataSet",
Settings = NULL,
OutputName = "CurationOutput")
CDSTableCheck <- ds.GetDataSetCheck(DataSetName = "CuratedDataSet",
Stage = "Curated")
# Get curation reports
CurationReport <- ds.GetCurationReport()
# Run ds.AugmentData
ds.AugmentData(CuratedDataSetName = "CuratedDataSet",
OutputName = "AugmentationOutput")
ADSTableCheck <- ds.GetDataSetCheck(DataSetName = "AugmentedDataSet")
devtools::load_all(".")
library(dsBaseClient)
library(dsFredaClient)
library(dsTidyverseClient)
library(resourcer)
# Print DataSHIELD errors right away
options(datashield.errors.print = TRUE)
#TestData <- readRDS("../dsCCPhos/Development/Data/RealData/CCPRealData_Frankfurt.rds")
TestData <- readRDS("../dsCCPhos/Development/Data/TestData/CCPTestData.rds")
CCPConnections <- ConnectToVirtualCCP(CCPTestData = TestData,
NumberOfServers = 3,
NumberOfPatientsPerServer = 2000,
AddedDsPackages = "dsTidyverse")
devtools::load_all(".")
CCPConnections <- ConnectToVirtualCCP(CCPTestData = TestData,
NumberOfServers = 3,
NumberOfPatientsPerServer = 2000,
AddedDsPackages = "dsTidyverse")
CheckServerRequirements()
LoadRawDataSet(ServerSpecifications = NULL)
# Transform Raw Data Set (RDS) into Curated Data Set (CDS) (using default settings)
ds.CurateData(RawDataSetName = "RawDataSet",
Settings = NULL,
OutputName = "CurationOutput")
# Run ds.AugmentData
ds.AugmentData(CuratedDataSetName = "CuratedDataSet",
OutputName = "AugmentationOutput")
# Collect comprehensive information about all workspace objects
ServerWorkspaceInfo <- GetServerWorkspaceInfo()
# Overview of all objects in server R sessions
View(ServerWorkspaceInfo$Overview)
# Overview of all objects in server R sessions
View(ServerWorkspaceInfo$Overview$All)
View(ServerWorkspaceInfo$ObjectDetails$All$ADS.Diagnosis)
View(dsCCPhosClient::Meta.ADS)
# --- For Testing Purposes ---
OrderList <- list(ADS.Diagnosis = c("Grading",
"PatientAgeAtDiagnosis",
"TNM.T"))
DSConnections <- CCPConnections
library(purrr)
Exploration <- OrderList %>%
imap(function(FeatureNames, tablename)
{
for (featurename in FeatureNames)
{
dsFredaClient::ExploreFeature(TableName = tablename,
FeatureName = featurename,
DSConnections = DSConnections)
}
})
Exploration$ADS.Diagnosis
dsFredaClient::ExploreFeature(TableName = "ADS.Diagnosis",
FeatureName = "Grading",
DSConnections = DSConnections)
Exploration <- OrderList %>%
imap(function(FeatureNames, tablename)
{
#for (featurename in FeatureNames)
FeatureNames %>% map(\(featurename) dsFredaClient::ExploreFeature(TableName = tablename,
FeatureName = featurename,
DSConnections = DSConnections))
})
Exploration$ADS.Diagnosis
Exploration <- OrderList %>%
imap(function(FeatureNames, tablename)
{
#for (featurename in FeatureNames)
FeatureNames %>%
map(\(featurename) dsFredaClient::ExploreFeature(TableName = tablename,
FeatureName = featurename,
DSConnections = DSConnections)) %>%
set_names(FeatureNames)
})
Exploration$ADS.Diagnosis$Grading$FeatureInfo
# --- For Testing Purposes ---
# OrderList <- list(ADS.Diagnosis = c("Grading",
#                                     "PatientAgeAtDiagnosis",
#                                     "TNM.T"))
InputWorkspaceInfo <- ServerWorkspaceInfo
SuitableTables <- InputWorkspaceInfo$Overview$All %>%
filter(Exists == TRUE,
Exists.Info == "Uniform",
Class == "data.frame",
Class.Info == "Uniform") %>%
pull(Object)
SuitableTables
OrderList <- InputWorkspaceInfo$ObjectDetails$All %>%
pluck(SuitableTables)
?pluck
OrderList <- InputWorkspaceInfo$ObjectDetails$All[SuitableTables]
?DSI::datashield.assign
