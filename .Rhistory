#url = "file://./Development/Test/DummyData.csv",
url = "file://localhost/C:/Users/Basti/ARBEIT Lokal/dsCCPhosClient/Development/Test/DummyData.csv",
format = "csv")
CCPConnections <- ConnectToVirtualCCP(CCPTestData = TestData,
NumberOfServers = 3,
NumberOfPatientsPerServer = 2000,
AddedDsPackages = "dsTidyverse")
Messages <- LoadRawDataSet(ServerSpecifications = NULL)
# Transform Raw Data Set (RDS) into Curated Data Set (CDS) (using default settings)
Curation <- ds.CurateData(RawDataSetName = "RawDataSet",
Settings = NULL,
OutputName = "CurationOutput")
devtools::load_all(".")
CDSTableCheck <- ds.CheckDataSet(DataSetName = "CuratedDataSet",
AssumeCCPDataSet = TRUE)
# Run ds.AugmentData
Messages <- ds.AugmentData(CuratedDataSetName = "CuratedDataSet",
OutputName = "AugmentationOutput")
# Make tables from Augmented Data Set directly addressable by unpacking them into R server session
Messages <- ds.UnpackAugmentedDataSet(AugmentedDataSetName = "AugmentedDataSet")
# --- For Testing Purposes ---
TableName <- "ADS_Patient"
FilterExpression <- "LastVitalStatus == 'Alive'"
GroupBy <- NULL
OutputName <- "Test"
DSConnections <- CCPConnections
# Execute server-side assign function
DSI::datashield.assign(conns = DSConnections,
symbol = OutputName,
value = call("FilterTableDS",
TableName.S = TableName,
FilterExpression.S = FilterExpression,
GroupBy.S = GroupBy))
UpdateLocalPackages()
# Execute server-side assign function
DSI::datashield.assign(conns = DSConnections,
symbol = OutputName,
value = call("FilterTableDS",
TableName.S = TableName,
FilterExpression.S = FilterExpression,
GroupBy.S = GroupBy))
#TestData <- readRDS("../dsCCPhos/Development/Data/RealData/CCPRealData_Frankfurt.rds")
TestData <- readRDS("../dsCCPhos/Development/Data/TestData/CCPTestData.rds")
# Definition of test resource, exemplary with local csv-file
TestResource <- resourcer::newResource(name = "TestResource",
#url = "file://./Development/Test/DummyData.csv",
url = "file://localhost/C:/Users/Basti/ARBEIT Lokal/dsCCPhosClient/Development/Test/DummyData.csv",
format = "csv")
CCPConnections <- ConnectToVirtualCCP(CCPTestData = TestData,
NumberOfServers = 3,
NumberOfPatientsPerServer = 2000,
AddedDsPackages = "dsTidyverse")
Messages <- LoadRawDataSet(ServerSpecifications = NULL)
rm(list=ls())
#TestData <- readRDS("../dsCCPhos/Development/Data/RealData/CCPRealData_Frankfurt.rds")
TestData <- readRDS("../dsCCPhos/Development/Data/TestData/CCPTestData.rds")
# Definition of test resource, exemplary with local csv-file
TestResource <- resourcer::newResource(name = "TestResource",
#url = "file://./Development/Test/DummyData.csv",
url = "file://localhost/C:/Users/Basti/ARBEIT Lokal/dsCCPhosClient/Development/Test/DummyData.csv",
format = "csv")
CCPConnections <- ConnectToVirtualCCP(CCPTestData = TestData,
NumberOfServers = 3,
NumberOfPatientsPerServer = 2000,
AddedDsPackages = "dsTidyverse")
Messages <- LoadRawDataSet(ServerSpecifications = NULL)
devtools::load_all(".")
library(dsBaseClient)
library(dsCCPhosClient)
library(dsTidyverseClient)
library(resourcer)
# Print DataSHIELD errors right away
options(datashield.errors.print = TRUE)
#TestData <- readRDS("../dsCCPhos/Development/Data/RealData/CCPRealData_Frankfurt.rds")
TestData <- readRDS("../dsCCPhos/Development/Data/TestData/CCPTestData.rds")
# Definition of test resource, exemplary with local csv-file
TestResource <- resourcer::newResource(name = "TestResource",
#url = "file://./Development/Test/DummyData.csv",
url = "file://localhost/C:/Users/Basti/ARBEIT Lokal/dsCCPhosClient/Development/Test/DummyData.csv",
format = "csv")
CCPConnections <- ConnectToVirtualCCP(CCPTestData = TestData,
NumberOfServers = 3,
NumberOfPatientsPerServer = 2000,
AddedDsPackages = "dsTidyverse")
Messages <- LoadRawDataSet(ServerSpecifications = NULL)
# Transform Raw Data Set (RDS) into Curated Data Set (CDS) (using default settings)
Curation <- ds.CurateData(RawDataSetName = "RawDataSet",
Settings = NULL,
OutputName = "CurationOutput")
# Run ds.AugmentData
Messages <- ds.AugmentData(CuratedDataSetName = "CuratedDataSet",
OutputName = "AugmentationOutput")
# Make tables from Augmented Data Set directly addressable by unpacking them into R server session
Messages <- ds.UnpackAugmentedDataSet(AugmentedDataSetName = "AugmentedDataSet")
# --- For Testing Purposes ---
TableName <- "ADS_Patient"
FilterExpression <- "LastVitalStatus == 'Alive'"
GroupBy <- NULL
OutputName <- "Test"
DSConnections <- CCPConnections
# Execute server-side assign function
DSI::datashield.assign(conns = DSConnections,
symbol = OutputName,
value = call("FilterTableDS",
TableName.S = TableName,
FilterExpression.S = FilterExpression,
GroupBy.S = GroupBy))
rlang::last_trace()
devtools::load_all(".")
library(dsBaseClient)
library(dsCCPhosClient)
library(dsTidyverseClient)
library(resourcer)
# Print DataSHIELD errors right away
options(datashield.errors.print = TRUE)
#TestData <- readRDS("../dsCCPhos/Development/Data/RealData/CCPRealData_Frankfurt.rds")
TestData <- readRDS("../dsCCPhos/Development/Data/TestData/CCPTestData.rds")
# Definition of test resource, exemplary with local csv-file
TestResource <- resourcer::newResource(name = "TestResource",
#url = "file://./Development/Test/DummyData.csv",
url = "file://localhost/C:/Users/Basti/ARBEIT Lokal/dsCCPhosClient/Development/Test/DummyData.csv",
format = "csv")
CCPConnections <- ConnectToVirtualCCP(CCPTestData = TestData,
NumberOfServers = 3,
NumberOfPatientsPerServer = 2000,
AddedDsPackages = "dsTidyverse")
Requirements <- CheckServerRequirements()
Messages <- LoadRawDataSet(ServerSpecifications = NULL)
# Transform Raw Data Set (RDS) into Curated Data Set (CDS) (using default settings)
Curation <- ds.CurateData(RawDataSetName = "RawDataSet",
Settings = NULL,
OutputName = "CurationOutput")
# Make tables from Curated Data Set directly addressable by unpacking them into R server session
Messages <- ds.UnpackCuratedDataSet(CuratedDataSetName = "CuratedDataSet")
# --- For Testing Purposes ---
TableName <- "CDS_Patient"
FilterExpression <- "LastVitalStatus == 'Alive'"
GroupBy <- NULL
OutputName <- "Test"
DSConnections <- CCPConnections
# Execute server-side assign function
DSI::datashield.assign(conns = DSConnections,
symbol = OutputName,
value = call("FilterTableDS",
TableName.S = TableName,
FilterExpression.S = FilterExpression,
GroupBy.S = GroupBy))
?dsCCPhos::FilterTableDS
devtools::unload("dsCCPhos")
devtools::load_all(".")
library(dsBaseClient)
library(dsCCPhosClient)
library(dsTidyverseClient)
library(resourcer)
# Print DataSHIELD errors right away
options(datashield.errors.print = TRUE)
#TestData <- readRDS("../dsCCPhos/Development/Data/RealData/CCPRealData_Frankfurt.rds")
TestData <- readRDS("../dsCCPhos/Development/Data/TestData/CCPTestData.rds")
# Definition of test resource, exemplary with local csv-file
TestResource <- resourcer::newResource(name = "TestResource",
#url = "file://./Development/Test/DummyData.csv",
url = "file://localhost/C:/Users/Basti/ARBEIT Lokal/dsCCPhosClient/Development/Test/DummyData.csv",
format = "csv")
CCPConnections <- ConnectToVirtualCCP(CCPTestData = TestData,
NumberOfServers = 3,
NumberOfPatientsPerServer = 2000,
AddedDsPackages = "dsTidyverse")
Requirements <- CheckServerRequirements()
Messages <- LoadRawDataSet(ServerSpecifications = NULL)
# Transform Raw Data Set (RDS) into Curated Data Set (CDS) (using default settings)
Curation <- ds.CurateData(RawDataSetName = "RawDataSet",
Settings = NULL,
OutputName = "CurationOutput")
CDSTableCheck <- ds.CheckDataSet(DataSetName = "CuratedDataSet",
AssumeCCPDataSet = TRUE)
# Make tables from Curated Data Set directly addressable by unpacking them into R server session
Messages <- ds.UnpackCuratedDataSet(CuratedDataSetName = "CuratedDataSet")
# --- For Testing Purposes ---
TableName <- "CDS_Patient"
FilterExpression <- "LastVitalStatus == 'Alive'"
GroupBy <- NULL
OutputName <- "Test"
DSConnections <- CCPConnections
# Execute server-side assign function
DSI::datashield.assign(conns = DSConnections,
symbol = OutputName,
value = call("FilterTableDS",
TableName.S = TableName,
FilterExpression.S = FilterExpression,
GroupBy.S = GroupBy))
names(DSConnections)
FilterExpression <- "LastVitalStatus"
# Execute server-side assign function
DSI::datashield.assign(conns = DSConnections,
symbol = OutputName,
value = call("FilterTableDS",
TableName.S = TableName,
FilterExpression.S = FilterExpression,
GroupBy.S = GroupBy))
?DSLite::dsGetInfo()
DSLite::getDSLiteData(conns = CCPConnections, symbol = "Test")
Test <- DSLite::getDSLiteData(conns = CCPConnections, symbol = "CDS_Patient")
View(Test$ServerA)
FilterExpression <- enquo("LastVitalStatus == 'Alive'")
?quo_text
FilterExpression <- quo_text("LastVitalStatus == 'Alive'")
# Execute server-side assign function
DSI::datashield.assign(conns = DSConnections,
symbol = OutputName,
value = call("FilterTableDS",
TableName.S = TableName,
FilterExpression.S = FilterExpression,
GroupBy.S = GroupBy))
FilterExpression
FilterExpression <- "LastVitalStatus == 'Alive'"
devtools::load_all(".")
Test <- .encode_tidy_eval(FilterExpression)
Test <- .encode_tidy_eval(FilterExpression, .get_encode_dictionary())
Test
Test2 <- .decode_tidy_eval(Test, .get_encode_dictionary())
Test2
# --- For Testing Purposes ---
TableName <- "CDS_Patient"
FilterExpression <- "LastVitalStatus == 'Alive'"
GroupBy <- NULL
OutputName <- "Test"
DSConnections <- CCPConnections
FilterExpression <- .encode_tidy_eval(FilterExpression, .get_encode_dictionary())
# Execute server-side assign function
DSI::datashield.assign(conns = DSConnections,
symbol = OutputName,
value = call("FilterTableDS",
TableName.S = TableName,
FilterExpression.S = FilterExpression,
GroupBy.S = GroupBy))
rm(list = ls())
UpdateLocalPackages()
library(dsBaseClient)
library(dsCCPhosClient)
library(dsTidyverseClient)
library(resourcer)
# Print DataSHIELD errors right away
options(datashield.errors.print = TRUE)
#TestData <- readRDS("../dsCCPhos/Development/Data/RealData/CCPRealData_Frankfurt.rds")
TestData <- readRDS("../dsCCPhos/Development/Data/TestData/CCPTestData.rds")
# Definition of test resource, exemplary with local csv-file
TestResource <- resourcer::newResource(name = "TestResource",
#url = "file://./Development/Test/DummyData.csv",
url = "file://localhost/C:/Users/Basti/ARBEIT Lokal/dsCCPhosClient/Development/Test/DummyData.csv",
format = "csv")
CCPConnections <- ConnectToVirtualCCP(CCPTestData = TestData,
NumberOfServers = 3,
NumberOfPatientsPerServer = 2000,
AddedDsPackages = "dsTidyverse")
Messages <- LoadRawDataSet(ServerSpecifications = NULL)
devtools::load_all(".")
library(dsBaseClient)
library(dsCCPhosClient)
library(dsTidyverseClient)
library(resourcer)
# Print DataSHIELD errors right away
options(datashield.errors.print = TRUE)
#TestData <- readRDS("../dsCCPhos/Development/Data/RealData/CCPRealData_Frankfurt.rds")
TestData <- readRDS("../dsCCPhos/Development/Data/TestData/CCPTestData.rds")
# Definition of test resource, exemplary with local csv-file
TestResource <- resourcer::newResource(name = "TestResource",
#url = "file://./Development/Test/DummyData.csv",
url = "file://localhost/C:/Users/Basti/ARBEIT Lokal/dsCCPhosClient/Development/Test/DummyData.csv",
format = "csv")
CCPConnections <- ConnectToVirtualCCP(CCPTestData = TestData,
NumberOfServers = 3,
NumberOfPatientsPerServer = 2000,
AddedDsPackages = "dsTidyverse")
Requirements <- CheckServerRequirements()
Messages <- LoadRawDataSet(ServerSpecifications = NULL)
ds.DrawSample(RawDataSetName = "RawDataSet",
SampleSize = "1000",
SampleName = "RDSSample")
# Transform Raw Data Set (RDS) into Curated Data Set (CDS) (using default settings)
Curation <- ds.CurateData(RawDataSetName = "RawDataSet",
Settings = NULL,
OutputName = "CurationOutput")
# --- For Testing Purposes ---
TableName <- "CDS_Patient"
FilterExpression <- "LastVitalStatus == 'Alive'"
GroupBy <- NULL
OutputName <- "Test"
DSConnections <- CCPConnections
# Encode string in 'FilterExpression' to make it passable through DSI
FilterExpression <- .encode_tidy_eval(FilterExpression, .get_encode_dictionary())
# Execute server-side assign function
DSI::datashield.assign(conns = DSConnections,
symbol = OutputName,
value = call("FilterTableDS",
TableName.S = TableName,
FilterExpression.S = FilterExpression,
GroupBy.S = GroupBy))
# Make tables from Curated Data Set directly addressable by unpacking them into R server session
Messages <- ds.UnpackCuratedDataSet(CuratedDataSetName = "CuratedDataSet")
rm(DSConnections)
# Make tables from Curated Data Set directly addressable by unpacking them into R server session
Messages <- ds.UnpackCuratedDataSet(CuratedDataSetName = "CuratedDataSet")
DSConnections <- CCPConnections
# Execute server-side assign function
DSI::datashield.assign(conns = DSConnections,
symbol = OutputName,
value = call("FilterTableDS",
TableName.S = TableName,
FilterExpression.S = FilterExpression,
GroupBy.S = GroupBy))
Test <- DSLite::getDSLiteData(conns = CCPConnections, "Test")
View(Test$ServerA)
FilterExpression <- "LastVitalStatus == 'Alive' & Gender == 'male'"
# Encode string in 'FilterExpression' to make it passable through DSI
FilterExpression <- .encode_tidy_eval(FilterExpression, .get_encode_dictionary())
# Execute server-side assign function
DSI::datashield.assign(conns = DSConnections,
symbol = OutputName,
value = call("FilterTableDS",
TableName.S = TableName,
FilterExpression.S = FilterExpression,
GroupBy.S = GroupBy))
View(Test$ServerA)
FilterExpression <- "LastVitalStatus == 'Alive' & Gender == 'Male'"
# Encode string in 'FilterExpression' to make it passable through DSI
FilterExpression <- .encode_tidy_eval(FilterExpression, .get_encode_dictionary())
# Execute server-side assign function
DSI::datashield.assign(conns = DSConnections,
symbol = OutputName,
value = call("FilterTableDS",
TableName.S = TableName,
FilterExpression.S = FilterExpression,
GroupBy.S = GroupBy))
Test <- DSLite::getDSLiteData(conns = CCPConnections, "Test")
View(Test$ServerA)
View(Test$ServerA)
FilterExpression <- "LastVitalStatus == 'Alive' & str_starts(Gender, 'Ma')"
# Encode string in 'FilterExpression' to make it passable through DSI
FilterExpression <- .encode_tidy_eval(FilterExpression, .get_encode_dictionary())
# Execute server-side assign function
DSI::datashield.assign(conns = DSConnections,
symbol = OutputName,
value = call("FilterTableDS",
TableName.S = TableName,
FilterExpression.S = FilterExpression,
GroupBy.S = GroupBy))
Test <- DSLite::getDSLiteData(conns = CCPConnections, "Test")
View(Test$ServerA)
# Collect comprehensive information about all workspace objects
ServerWorkspaceInfo <- GetServerWorkspaceInfo()
rm(DSConnections)
# Collect comprehensive information about all workspace objects
ServerWorkspaceInfo <- GetServerWorkspaceInfo()
# Overview of all objects in server R sessions
View(ServerWorkspaceInfo$Overview)
# Detailed meta data of a particular object (also part of ServerWorkspaceInfo)
ObjectMetaData <- ds.GetObjectMetaData(ObjectName = "ADS_Patient")
# Explore Object meta data: Structural overview
View(ObjectMetaData$ServerA$Structure)
ObjectMetaData$ServerA$ObjectExists
# Detailed meta data of a particular object (also part of ServerWorkspaceInfo)
ObjectMetaData <- ds.GetObjectMetaData(ObjectName = "CDS_Patient")
# Explore Object meta data: Structural overview
View(ObjectMetaData$ServerA$Structure)
devtools::load_all(".")
devtools::load_all(".")
library(dsBaseClient)
library(dsCCPhosClient)
library(dsTidyverseClient)
library(resourcer)
# Print DataSHIELD errors right away
options(datashield.errors.print = TRUE)
#TestData <- readRDS("../dsCCPhos/Development/Data/RealData/CCPRealData_Frankfurt.rds")
TestData <- readRDS("../dsCCPhos/Development/Data/TestData/CCPTestData.rds")
# Definition of test resource, exemplary with local csv-file
TestResource <- resourcer::newResource(name = "TestResource",
#url = "file://./Development/Test/DummyData.csv",
url = "file://localhost/C:/Users/Basti/ARBEIT Lokal/dsCCPhosClient/Development/Test/DummyData.csv",
format = "csv")
CCPConnections <- ConnectToVirtualCCP(CCPTestData = TestData,
NumberOfServers = 3,
NumberOfPatientsPerServer = 2000,
AddedDsPackages = "dsTidyverse")
Messages <- LoadRawDataSet(ServerSpecifications = NULL)
ds.DrawSample(RawDataSetName = "RawDataSet",
SampleSize = "1000",
SampleName = "RDSSample")
# Transform Raw Data Set (RDS) into Curated Data Set (CDS) (using default settings)
Curation <- ds.CurateData(RawDataSetName = "RawDataSet",
Settings = NULL,
OutputName = "CurationOutput")
# Make tables from Curated Data Set directly addressable by unpacking them into R server session
Messages <- ds.UnpackCuratedDataSet(CuratedDataSetName = "CuratedDataSet")
# --- For Testing Purposes ---
TableName <- "CDS_Staging"
FeatureName <- "TNM_T"
DSConnections <- CCPConnections
require(dsBaseClient)
require(dplyr)
require(purrr)
# Get meta data of table object
TableMetaData <- ds.GetObjectMetaData(ObjectName = TableName,
DSConnections = DSConnections)
# Stop execution if referred table object is not a data.frame
if (TableMetaData$FirstEligible$Class != "data.frame") { stop("Error: The referred table object does not seem to be a data.frame.", call. = FALSE)}
# ServerReturns: Obtain feature properties for each server calling dsCCPhos::GetFeatureInfoDS()
ServerReturns <- DSI::datashield.aggregate(conns = DSConnections,
expr = call("GetFeatureInfoDS",
TableName.S = TableName,
FeatureName.S = FeatureName))
# Convert Server returns into tibble containing separate feature meta data
SeparateProperties <- ServerReturns %>%
list_rbind(names_to = "Server")
# Obtaining return value for cumulated feature data type
ReturnedFeatureDataTypes <- unique(SeparateProperties$DataType[!is.na(SeparateProperties$DataType)])
CumulatedDataType <- NA
if (length(ReturnedFeatureDataTypes) == 1) { CumulatedDataType <- ReturnedFeatureDataTypes }
if (length(ReturnedFeatureDataTypes) > 1) { CumulatedDataType <- "Inconclusive"}
# Obtain cumulated feature meta data
CumulatedProperties <- tibble(Server = "All",
DataType = CumulatedDataType,
N_Total = sum(SeparateProperties$N_Total),
N_Valid = sum(SeparateProperties$N_Valid),
ValidProportion = N_Valid / N_Total,
N_Missing = sum(SeparateProperties$N_Missing),
MissingProportion = N_Missing / N_Total)
# Obtain cumulated feature meta data
CumulatedProperties <- tibble(Server = "All",
DataType = CumulatedDataType,
N.Total = sum(SeparateProperties$N.Total),
N.Valid = sum(SeparateProperties$N.Valid),
ValidProportion = N.Valid / N.Total,
N.Missing = sum(SeparateProperties$N_Missing),
MissingProportion = N.Missing / N.Total)
# Obtain cumulated feature meta data
CumulatedProperties <- tibble(Server = "All",
DataType = CumulatedDataType,
N.Total = sum(SeparateProperties$N.Total),
N.Valid = sum(SeparateProperties$N.Valid),
ValidProportion = N.Valid / N.Total,
N.Missing = sum(SeparateProperties$N.Missing),
MissingProportion = N.Missing / N.Total)
CumulatedProperties
EligibleValues <- NULL
# If Feature of concern is of class character
if (CumulatedDataType == "character")
{
EligibleValues <- GetEligibleValues(TableName = TableName,
FeatureName = FeatureName)
}
EligibleValues
dsCCPhosClient::Meta_Values
devtools::load_all(".")
EligibleValues <- GetEligibleValues(TableName = TableName,
FeatureName = FeatureName)
EligibleValues
View(dsCCPhosClient::Meta_Values)
# --- For Testing Purposes ---
TableName = "Surgery"
FeatureName = "Intention"
Stage = "Curated"
EligibleValues <- dsCCPhosClient::Meta_Values %>%
filter(Table == TableName,
Feature == FeatureName) %>%
{ if (Stage == "Raw") { pull(., Value_Raw) }
else { pull(., Value_Curated) } }
EligibleValues
# --- For Testing Purposes ---
TableName <- "CDS_Staging"
FeatureName <- "TNM_T"
DSConnections <- CCPConnections
EligibleValues <- GetEligibleValues(TableName = TableName,
FeatureName = FeatureName)
EligibleValues
# Get meta data of table object
TableMetaData <- ds.GetObjectMetaData(ObjectName = TableName,
DSConnections = DSConnections)
# Stop execution if referred table object is not a data.frame
if (TableMetaData$FirstEligible$Class != "data.frame") { stop("Error: The referred table object does not seem to be a data.frame.", call. = FALSE)}
# ServerReturns: Obtain feature properties for each server calling dsCCPhos::GetFeatureInfoDS()
ServerReturns <- DSI::datashield.aggregate(conns = DSConnections,
expr = call("GetFeatureInfoDS",
TableName.S = TableName,
FeatureName.S = FeatureName))
# Convert Server returns into tibble containing separate feature meta data
SeparateProperties <- ServerReturns %>%
list_rbind(names_to = "Server")
# Obtaining return value for cumulated feature data type
ReturnedFeatureDataTypes <- unique(SeparateProperties$DataType[!is.na(SeparateProperties$DataType)])
CumulatedDataType <- NA
if (length(ReturnedFeatureDataTypes) == 1) { CumulatedDataType <- ReturnedFeatureDataTypes }
if (length(ReturnedFeatureDataTypes) > 1) { CumulatedDataType <- "Inconclusive"}
# Obtain cumulated feature meta data
CumulatedProperties <- tibble(Server = "All",
DataType = CumulatedDataType,
N.Total = sum(SeparateProperties$N.Total),
N.Valid = sum(SeparateProperties$N.Valid),
ValidProportion = N.Valid / N.Total,
N.Missing = sum(SeparateProperties$N.Missing),
MissingProportion = N.Missing / N.Total)
EligibleValues <- NULL
# If Feature of concern is of class character
if (CumulatedDataType == "character")
{
EligibleValues <- GetEligibleValues(TableName = TableName,
FeatureName = FeatureName)
}
EligibleValues
GetEligibleValues("Staging", "TNM_T")
EligibleValues <- GetEligibleValues(TableName,
FeatureName)
EligibleValues
