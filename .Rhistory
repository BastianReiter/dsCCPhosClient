}
# Get vector of all Opal table names that are available on the current server
AvailableOpalTables <- OpalTableAvailability %>%
rename(IsAvailable = ServerNames[i]) %>%
filter(IsAvailable == TRUE) %>%
pull(TableName) %>%
paste0(ServerProjectName, .)
AvailableOpalTables
devtools::load_all(".")
library(dsBaseClient)
library(dsCCPhosClient)
library(dsTidyverseClient)
library(resourcer)
# Print DataSHIELD errors right away
options(datashield.errors.print = TRUE)
#TestData <- readRDS("../dsCCPhos/Development/Data/RealData/CCPRealData_Frankfurt.rds")
TestData <- readRDS("../dsCCPhos/Development/Data/TestData/CCPTestData.rds")
# Definition of test resource, exemplary with local csv-file
TestResource <- resourcer::newResource(name = "TestResource",
#url = "file://./Development/Test/DummyData.csv",
url = "file://localhost/C:/Users/Basti/ARBEIT Lokal/dsCCPhosClient/Development/Test/DummyData.csv",
format = "csv")
CCPConnections <- ConnectToVirtualCCP(CCPTestData = TestData,
NumberOfSites = 3,
NumberOfPatientsPerSite = 2000,
AddedDsPackages = "dsTidyverse")
Requirements <- CheckServerRequirements()
Messages <- LoadRawDataSet(SiteSpecifications = NULL)
RDSTableCheck <- ds.CheckDataSet(DataSetName = "RawDataSet",
AssumeCCPDataSet = TRUE)
library(devtools)
library(dplyr)
# General / Auxiliary functions
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# use_r("Auxiliary.R")
# use_r("CheckServerRequirements.R")
# use_r("ConnectToCCP.R")
# use_r("ConnectToVirtualCCP.R")
# use_r("DisplayTimeSeries.R")
# use_r("ExploreFeature.R")
use_r("GetEligibleValues.R")
View(Meta_Features)
devtools::load_all(".")
View(Meta_Features)
View(Meta_Values)
TableName = "Surgery"
FeatureName = "Intention"
Stage = "Curated"
HasValueSet <- Meta_Values %>%
filter(Table == TableName,
Feature == FeatureName) %>%
{ if (Stage == "Raw") { pull(., Value_Raw) }
else { pull(., Value_Curated) } }
FeatureName <- "ABC"
EligibleValues <- Meta_Values %>%
filter(Table == TableName,
Feature == FeatureName) %>%
{ if (Stage == "Raw") { pull(., Value_Raw) }
else { pull(., Value_Curated) } }
is.null(EligibleValues)
purrr::is_empty(EligibleValues)
library(dsBaseClient)
library(dsCCPhosClient)
library(dsTidyverseClient)
library(resourcer)
# Print DataSHIELD errors right away
options(datashield.errors.print = TRUE)
#TestData <- readRDS("../dsCCPhos/Development/Data/RealData/CCPRealData_Frankfurt.rds")
TestData <- readRDS("../dsCCPhos/Development/Data/TestData/CCPTestData.rds")
# Definition of test resource, exemplary with local csv-file
TestResource <- resourcer::newResource(name = "TestResource",
#url = "file://./Development/Test/DummyData.csv",
url = "file://localhost/C:/Users/Basti/ARBEIT Lokal/dsCCPhosClient/Development/Test/DummyData.csv",
format = "csv")
CCPConnections <- ConnectToVirtualCCP(CCPTestData = TestData,
NumberOfServers = 3,
NumberOfPatientsPerServer = 2000,
AddedDsPackages = "dsTidyverse")
ServerSpecifications <- NULL
DSConnections <- CCPConnections
# Check Opal table availability before assignment
OpalTableAvailability <- GetServerOpalInfo(ServerSpecifications = ServerSpecifications,
DSConnections = DSConnections)
OpalTableAvailability
# Get overview of available tables on servers
TableAvailability <- DSI::datashield.tables(conns = DSConnections)
TableAvailability
# --- For testing purposes ---
ServerSpecifications <- NULL
RawTableNames = dsCCPhosClient::Meta_Tables$TableName_Raw,
# Check validity of 'DSConnections' or find them programmatically if none are passed
DSConnections <- CheckDSConnections(DSConnections)
# --- For testing purposes ---
ServerSpecifications <- NULL
RawTableNames = dsCCPhosClient::Meta_Tables$TableName_Raw
CuratedTableNames = dsCCPhosClient::Meta_Tables$TableName_Curated
DSConnections <- CCPConnections
# Check Opal table availability before assignment
OpalTableAvailability <- GetServerOpalInfo(ServerSpecifications = ServerSpecifications,
RequiredTableNames = RawTableNames,
DSConnections = DSConnections)
devtools::load_all(".")
# Check Opal table availability before assignment
OpalTableAvailability <- GetServerOpalInfo(ServerSpecifications = ServerSpecifications,
RequiredTableNames = RawTableNames,
DSConnections = DSConnections)
OpalTableAvailability
# Get overview of available tables on servers
TableAvailability <- DSI::datashield.tables(conns = DSConnections)
TableAvailability
OpalTableAvailability
i <- 1
# In case ServerSpecifications are NULL, server Opal table names are just raw CCP table names
ServerTableNames <- RawTableNames
ServerProjectName <- NULL
# Get vector of all Opal table names that are available on the current server
AvailableOpalTables <- OpalTableAvailability %>%
rename(IsAvailable = ServerNames[i]) %>%
filter(IsAvailable == TRUE) %>%
pull(TableName) %>%
paste0(ServerProjectName, .)
# Get server names
ServerNames <- names(DSConnections)
# Initiate output messaging objects
Messages <- list()
Messages$Assignment <- c(Topic = "Object assignment on servers")
# Get vector of all Opal table names that are available on the current server
AvailableOpalTables <- OpalTableAvailability %>%
rename(IsAvailable = ServerNames[i]) %>%
filter(IsAvailable == TRUE) %>%
pull(TableName) %>%
paste0(ServerProjectName, .)
AvailableOpalTables
# Check Opal table availability before assignment
OpalTableAvailability.Raw <- GetServerOpalInfo(ServerSpecifications = ServerSpecifications,
RequiredTableNames = RawTableNames,
DSConnections = DSConnections)
OpalTableAvailability.Curated <- GetServerOpalInfo(ServerSpecifications = ServerSpecifications,
RequiredTableNames = CuratedTableNames,
DSConnections = DSConnections)
OpalTableAvailability.Curated
OpalTableAvailability.Raw
OpalTableAvailability <- bind_rows(OpalTableAvailability.Raw,
OpalTableAvailability.Curated)
i <- 1
# In case ServerSpecifications are NULL, server Opal table names are just raw CCP table names
ServerTableNames <- RawTableNames
ServerProjectName <- NULL
# Get vector of all Opal table names that are available on the current server
AvailableOpalTables <- OpalTableAvailability %>%
rename(IsAvailable = ServerNames[i]) %>%
filter(IsAvailable == TRUE) %>%
pull(TableName) %>%
paste0(ServerProjectName, .)
AvailableOpalTables
# Get vector of all Opal table names that are available on the current server
AvailableOpalTables <- OpalTableAvailability %>%
rename(IsAvailable = ServerNames[i]) %>%
filter(IsAvailable == TRUE) %>%
pull(TableName) %>%
unique() %>%
paste0(ServerProjectName, .)
AvailableOpalTables
OpalTableAvailability
View(OpalTableAvailability)
# Check Opal table availability with raw table names...
OpalTableAvailability.Raw <- GetServerOpalInfo(ServerSpecifications = ServerSpecifications,
RequiredTableNames = c(RawTableNames,
CuratedTableNames),
DSConnections = DSConnections)
View(OpalTableAvailability.Raw)
# Check Opal table availability with raw table names...
OpalTableAvailability <- GetServerOpalInfo(ServerSpecifications = ServerSpecifications,
RequiredTableNames = c(RawTableNames,
CuratedTableNames),   # ... Check also curated table names (some servers might already have adopted 'curated' table names)
DSConnections = DSConnections)
View(OpalTableAvailability)
ServerProjectName <- "Test."
# Create vector with server-specific table names (server-specific project name concatenated with raw table names)
ServerTableNames <- paste0(ServerProjectName, c(RawTableNames, CuratedTableNames))
ServerTableNames
i <- 1
# In case ServerSpecifications are NULL, server Opal table names are just raw (and curated to be sure) table names without attached project names
ServerTableNames <- c(RawTableNames, CuratedTableNames)
ServerProjectName <- NULL
# Get vector of all Opal table names that are available on the current server
AvailableOpalTables <- OpalTableAvailability %>%
rename(IsAvailable = ServerNames[i]) %>%
filter(IsAvailable == TRUE) %>%
pull(TableName) %>%
unique() %>%
paste0(ServerProjectName, .)
AvailableOpalTables
OpalTableAvailability
# Get vector of all Opal table names that are available on the current server
AvailableOpalTables <- OpalTableAvailability %>%
bind_cols(ServerTableNames)
AvailableOpalTables
View(AvailableOpalTables)
# Get vector of all Opal table names that are available on the current server
AvailableOpalTables <- OpalTableAvailability %>%
mutate(CuratedTableName = ServerTableNames)
View(AvailableOpalTables)
# Get vector of all Opal table names that are available on the current server
AvailableOpalTables <- OpalTableAvailability %>%
mutate(OpalTableName = ServerTableNames)
# Get vector of all Opal table names that are available on the current server
AvailableOpalTables <- OpalTableAvailability %>%
mutate(OpalTableName = ServerTableNames) %>%
rename(IsAvailable = ServerNames[i]) %>%
filter(IsAvailable == TRUE)
# Compile a vector of table names to look for in server Opal data bases
# Usually this should be 'RawTableNames' but also check 'CuratedTableNames' because some servers might already have adopted 'curated' table names
TableNamesToLookFor <- c(RawTableNames,
CuratedTableNames)
# Check Opal table availability with raw table names...
OpalTableAvailability <- GetServerOpalInfo(ServerSpecifications = ServerSpecifications,
RequiredTableNames = TableNamesToLookFor,
DSConnections = DSConnections)
# In case ServerSpecifications are NULL, server Opal table will not be concatenated with server-specific project names
ServerTableNames <- TableNamesToLookFor
ServerProjectName <- NULL
# Get vector of all Opal table names that are available on the current server
AvailableOpalTables <- OpalTableAvailability %>%
mutate(OpalTableName = ServerTableNames) %>%
rename(IsAvailable = ServerNames[i]) %>%
filter(IsAvailable == TRUE)
# Get vector of all Opal table names that are available on the current server
AvailableOpalTables <- OpalTableAvailability %>%
mutate(OpalTableName = paste0(ServerProjectName, TableName)) %>%   # Create feature with server-specific table names (server-specific project name concatenated with generic table names)
rename(IsAvailable = ServerNames[i]) %>%
filter(IsAvailable == TRUE)
ServerProjectName <- "Test."
# Get vector of all Opal table names that are available on the current server
AvailableOpalTables <- OpalTableAvailability %>%
mutate(OpalTableName = paste0(ServerProjectName, TableName)) %>%   # Create feature with server-specific table names (server-specific project name concatenated with generic table names)
rename(IsAvailable = ServerNames[i]) %>%
filter(IsAvailable == TRUE)
# Get vector of all Opal table names that are available on the current server
AvailableOpalTables <- OpalTableAvailability %>%
rename(IsAvailable = ServerNames[i]) %>%
filter(IsAvailable == TRUE) %>%
distinct() %>%
mutate(OpalTableName = paste0(ServerProjectName, TableName)) %>%   # Create feature with server-specific table names (server-specific project name concatenated with generic table names)
# Loop through all tables from Opal DB and assign their content to objects (data.frames) in R session
for (j in 1:length(ServerTableNames))
# Get vector of all Opal table names that are available on the current server
AvailableOpalTables <- OpalTableAvailability %>%
rename(IsAvailable = ServerNames[i]) %>%
filter(IsAvailable == TRUE) %>%
distinct() %>%
mutate(OpalTableName = paste0(ServerProjectName, TableName))   # Create feature with server-specific table names (server-specific project name concatenated with generic table names)
# Get vector of all Opal table names that are available on the current server
AvailableOpalTables <- OpalTableAvailability %>%
rename(IsAvailable = ServerNames[i]) %>%
select(TableName,
IsAvailable) %>%
filter(IsAvailable == TRUE) %>%
distinct() %>%
mutate(OpalTableName = paste0(ServerProjectName, TableName))   # Create feature with server-specific table names (server-specific project name concatenated with generic table names)
?recode
Test <- setNames(CuratedTableNames, nm = RawTableNames)
Test["sample"]
# Get vector of all Opal table names that are available on the current server
AvailableOpalTables <- OpalTableAvailability %>%
rename(IsAvailable = ServerNames[i]) %>%
select(TableName,
IsAvailable) %>%
filter(IsAvailable == TRUE) %>%
distinct() %>%
mutate(OpalTableName = paste0(ServerProjectName, TableName),   # Create feature with server-specific table names (server-specific project name concatenated with generic table names)
TableName = paste0("RDS_", setNames(CuratedTableNames, nm = RawTableNames)[TableName]))
setNames(CuratedTableNames, nm = RawTableNames)["GeneralCondition"]
setNames(CuratedTableNames, nm = RawTableNames)["TherapyRecommendation"]
# Get vector of all Opal table names that are available on the current server
AvailableOpalTables <- OpalTableAvailability %>%
rename(IsAvailable = ServerNames[i]) %>%
select(TableName,
IsAvailable) %>%
filter(IsAvailable == TRUE) %>%
distinct() %>%
mutate(OpalTableName = paste0(ServerProjectName, TableName),   # Create feature with server-specific table names (server-specific project name concatenated with generic table names)
TableName = case_when(TableName %in% RawTableNames ~ paste0("RDS_", setNames(CuratedTableNames, nm = RawTableNames)[TableName]),
.default ~ paste0("RDS_", TableName)))
?case_when
# Get vector of all Opal table names that are available on the current server
AvailableOpalTables <- OpalTableAvailability %>%
rename(IsAvailable = ServerNames[i]) %>%
select(TableName,
IsAvailable) %>%
filter(IsAvailable == TRUE) %>%
distinct() %>%
mutate(OpalTableName = paste0(ServerProjectName, TableName),   # Create feature with server-specific table names (server-specific project name concatenated with generic table names)
TableName = case_when(TableName %in% RawTableNames ~ paste0("RDS_", setNames(CuratedTableNames, nm = RawTableNames)[TableName]),
.default = paste0("RDS_", TableName)))
# Create tibble that takes only available Opal tables and matches their names to R symbol names that are used in following assignment
TableNameMatching <- OpalTableAvailability %>%
rename(IsAvailable = ServerNames[i]) %>%
select(TableName,
IsAvailable) %>%
filter(IsAvailable == TRUE) %>%
distinct() %>%
mutate(# Create feature with server-specific table names (server-specific project name concatenated with generic table names)
OpalTableName = paste0(ServerProjectName, TableName),
# Turn 'RawTableNames' into 'CuratedTableNames' where necessary and concatenate with prefix 'RDS_'
RTableName = case_when(TableName %in% RawTableNames ~ paste0("RDS_", setNames(CuratedTableNames, nm = RawTableNames)[TableName]),
.default = paste0("RDS_", TableName)))
devtools::load_all(".")
library(dsBaseClient)
library(dsCCPhosClient)
library(dsTidyverseClient)
library(resourcer)
# Print DataSHIELD errors right away
options(datashield.errors.print = TRUE)
#TestData <- readRDS("../dsCCPhos/Development/Data/RealData/CCPRealData_Frankfurt.rds")
TestData <- readRDS("../dsCCPhos/Development/Data/TestData/CCPTestData.rds")
# Definition of test resource, exemplary with local csv-file
TestResource <- resourcer::newResource(name = "TestResource",
#url = "file://./Development/Test/DummyData.csv",
url = "file://localhost/C:/Users/Basti/ARBEIT Lokal/dsCCPhosClient/Development/Test/DummyData.csv",
format = "csv")
CCPConnections <- ConnectToVirtualCCP(CCPTestData = TestData,
NumberOfServers = 3,
NumberOfPatientsPerServer = 2000,
AddedDsPackages = "dsTidyverse")
Messages <- LoadRawDataSet(ServerSpecifications = NULL)
rm(list=ls())
library(dsBaseClient)
library(dsCCPhosClient)
library(dsTidyverseClient)
library(resourcer)
# Print DataSHIELD errors right away
options(datashield.errors.print = TRUE)
#TestData <- readRDS("../dsCCPhos/Development/Data/RealData/CCPRealData_Frankfurt.rds")
TestData <- readRDS("../dsCCPhos/Development/Data/TestData/CCPTestData.rds")
# Definition of test resource, exemplary with local csv-file
TestResource <- resourcer::newResource(name = "TestResource",
#url = "file://./Development/Test/DummyData.csv",
url = "file://localhost/C:/Users/Basti/ARBEIT Lokal/dsCCPhosClient/Development/Test/DummyData.csv",
format = "csv")
CCPConnections <- ConnectToVirtualCCP(CCPTestData = TestData,
NumberOfServers = 3,
NumberOfPatientsPerServer = 2000,
AddedDsPackages = "dsTidyverse")
?datashield.connections_default()
Requirements <- CheckServerRequirements()
devtools::load_all(".")
CCPConnections <- ConnectToVirtualCCP(CCPTestData = TestData,
NumberOfServers = 3,
NumberOfPatientsPerServer = 2000,
AddedDsPackages = "dsTidyverse")
Requirements <- CheckServerRequirements()
devtools::load_all(".")
Requirements <- CheckServerRequirements()
Messages <- LoadRawDataSet(ServerSpecifications = NULL)
warnings()
ServerSpecifications <- NULL
RawTableNames = dsCCPhosClient::Meta_Tables$TableName_Raw
CuratedTableNames = dsCCPhosClient::Meta_Tables$TableName_Curated
DSConnections <- CCPConnections
# Check validity of 'DSConnections' or find them programmatically if none are passed
DSConnections <- CheckDSConnections(DSConnections)
# Initiate output messaging objects
Messages <- list()
Messages$Assignment <- c(Topic = "Object assignment on servers")
# Get server names
ServerNames <- names(DSConnections)
# Compile a vector of table names to look for in server Opal data bases
# Usually this should be 'RawTableNames' but also check 'CuratedTableNames' because some servers might already have adopted 'curated' table names
TableNamesToLookFor <- c(RawTableNames,
CuratedTableNames)
# Check Opal table availability
OpalTableAvailability <- GetServerOpalInfo(ServerSpecifications = ServerSpecifications,
RequiredTableNames = TableNamesToLookFor,
DSConnections = DSConnections)
# Loop through all participating servers
for (i in 1:length(ServerNames))
{
# In case ServerSpecifications are NULL, server Opal table will not be concatenated with server-specific project names
ServerTableNames <- TableNamesToLookFor
ServerProjectName <- NULL
# If ServerSpecifications are assigned, there can be server-specific project names and therefore server-specific Opal table names
if (!is.null(ServerSpecifications))
{
# Get server-specific project name
ServerProjectName <- ServerSpecifications %>%
filter(ServerName == ServerNames[i]) %>%
select(ProjectName) %>%
pull()
# If ServerProjectName is "Virtual" (as it is the case when using virtual infrastructure in CCPhosApp) make the variable empty so that server Opal table names are just raw table names
if (ServerProjectName == "Virtual") { ServerProjectName <- "" }
# Else add a dot ('.') to ServerProjectName according to Opal table name nomenclature
else { ServerProjectName <- paste0(ServerProjectName, ".") }
}
# Create tibble that takes only available Opal tables and matches their names to R symbol names that are used in following assignment
TableNameMatching <- OpalTableAvailability %>%
rename(IsAvailable = ServerNames[i]) %>%
select(TableName,
IsAvailable) %>%
filter(IsAvailable == TRUE) %>%
distinct() %>%
mutate(# Create feature with server-specific table names (server-specific project name concatenated with generic table names)
OpalTableName = paste0(ServerProjectName, TableName),
# Turn 'RawTableNames' into 'CuratedTableNames' where necessary and concatenate with prefix 'RDS_'
RTableName = case_when(TableName %in% RawTableNames ~ paste0("RDS_", setNames(CuratedTableNames, nm = RawTableNames)[TableName]),
.default = paste0("RDS_", TableName)))
# Loop through available Opal DB tables and assign their content to objects (data.frames) in R session
for (j in 1:nrow(TableNameMatching))
{
datashield.assign(conns = DSConnections[[i]],
symbol = TableNameMatching$RTableName,
value = TableNameMatching$OpalTableName,
id.name = "_id")
}
}
i <- 1
# In case ServerSpecifications are NULL, server Opal table will not be concatenated with server-specific project names
ServerTableNames <- TableNamesToLookFor
ServerProjectName <- NULL
# If ServerSpecifications are assigned, there can be server-specific project names and therefore server-specific Opal table names
if (!is.null(ServerSpecifications))
{
# Get server-specific project name
ServerProjectName <- ServerSpecifications %>%
filter(ServerName == ServerNames[i]) %>%
select(ProjectName) %>%
pull()
# If ServerProjectName is "Virtual" (as it is the case when using virtual infrastructure in CCPhosApp) make the variable empty so that server Opal table names are just raw table names
if (ServerProjectName == "Virtual") { ServerProjectName <- "" }
# Else add a dot ('.') to ServerProjectName according to Opal table name nomenclature
else { ServerProjectName <- paste0(ServerProjectName, ".") }
}
# Create tibble that takes only available Opal tables and matches their names to R symbol names that are used in following assignment
TableNameMatching <- OpalTableAvailability %>%
rename(IsAvailable = ServerNames[i]) %>%
select(TableName,
IsAvailable) %>%
filter(IsAvailable == TRUE) %>%
distinct() %>%
mutate(# Create feature with server-specific table names (server-specific project name concatenated with generic table names)
OpalTableName = paste0(ServerProjectName, TableName),
# Turn 'RawTableNames' into 'CuratedTableNames' where necessary and concatenate with prefix 'RDS_'
RTableName = case_when(TableName %in% RawTableNames ~ paste0("RDS_", setNames(CuratedTableNames, nm = RawTableNames)[TableName]),
.default = paste0("RDS_", TableName)))
View(TableNameMatching)
nrow(TableNameMatching)
TableNameMatching$RTableName[2]
# Create tibble that takes only available Opal tables and matches their names to R symbol names that are used in following assignment
TableNameMatching <- OpalTableAvailability %>%
rename(IsAvailable = ServerNames[i]) %>%
select(TableName,
IsAvailable) %>%
filter(IsAvailable == TRUE) %>%
distinct() %>%
mutate(# Create feature with server-specific table names (server-specific project name concatenated with generic table names)
OpalTableName = paste0(ServerProjectName, TableName),
# Turn 'RawTableNames' into 'CuratedTableNames' where necessary and concatenate with prefix 'RDS_'
RTableName = case_when(TableName %in% RawTableNames ~ paste0("RDS_", setNames(CuratedTableNames, nm = RawTableNames)[TableName]),
.default = paste0("RDS_", TableName)))
# Loop through available Opal DB tables and assign their content to objects (data.frames) in R session
for (j in 1:nrow(TableNameMatching))
{
datashield.assign(conns = DSConnections[[i]],
symbol = TableNameMatching$RTableName[j],
value = TableNameMatching$OpalTableName[j],
id.name = "_id")
}
devtools::load_all(".")
rm(list=ls())
library(dsBaseClient)
library(dsCCPhosClient)
library(dsTidyverseClient)
library(resourcer)
# Print DataSHIELD errors right away
options(datashield.errors.print = TRUE)
#TestData <- readRDS("../dsCCPhos/Development/Data/RealData/CCPRealData_Frankfurt.rds")
TestData <- readRDS("../dsCCPhos/Development/Data/TestData/CCPTestData.rds")
# Definition of test resource, exemplary with local csv-file
TestResource <- resourcer::newResource(name = "TestResource",
#url = "file://./Development/Test/DummyData.csv",
url = "file://localhost/C:/Users/Basti/ARBEIT Lokal/dsCCPhosClient/Development/Test/DummyData.csv",
format = "csv")
CCPConnections <- ConnectToVirtualCCP(CCPTestData = TestData,
NumberOfServers = 3,
NumberOfPatientsPerServer = 2000,
AddedDsPackages = "dsTidyverse")
Requirements <- CheckServerRequirements()
Messages <- LoadRawDataSet(ServerSpecifications = NULL)
?dsTidyverseClient::ds.filter
devtools::load_all(".")
library(dsBaseClient)
library(dsCCPhosClient)
library(dsTidyverseClient)
library(resourcer)
# Print DataSHIELD errors right away
options(datashield.errors.print = TRUE)
#TestData <- readRDS("../dsCCPhos/Development/Data/RealData/CCPRealData_Frankfurt.rds")
TestData <- readRDS("../dsCCPhos/Development/Data/TestData/CCPTestData.rds")
# Definition of test resource, exemplary with local csv-file
TestResource <- resourcer::newResource(name = "TestResource",
#url = "file://./Development/Test/DummyData.csv",
url = "file://localhost/C:/Users/Basti/ARBEIT Lokal/dsCCPhosClient/Development/Test/DummyData.csv",
format = "csv")
CCPConnections <- ConnectToVirtualCCP(CCPTestData = TestData,
NumberOfServers = 3,
NumberOfPatientsPerServer = 2000,
AddedDsPackages = "dsTidyverse")
Requirements <- CheckServerRequirements()
Messages <- LoadRawDataSet(ServerSpecifications = NULL)
# Transform Raw Data Set (RDS) into Curated Data Set (CDS) (using default settings)
Curation <- ds.CurateData(RawDataSetName = "RawDataSet",
OutputName = "CurationOutput")
