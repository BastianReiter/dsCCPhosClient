# Transform Raw Data Set (RDS) into Curated Data Set (CDS)
dsCCPhosClient::ds.CurateData(Name_RawDataSet = "RawDataSet",
Name_Output = "CurationOutput",
DataSources = CCPConnections)
LETTERS[100]
LETTERS[30]
LETTERS[20]
LETTERS[24]
LETTERS[26]
?stop
devtools::load_all(".")
CCPConnections <- ConnectToVirtualCCP(CCPTestData = CCPTestData_Total,
NumberOfSites = 30,
NumberOfPatientsPerSite = 300)
devtools::load_all(".")
CCPConnections <- ConnectToVirtualCCP(CCPTestData = CCPTestData_Total,
NumberOfSites = 30,
NumberOfPatientsPerSite = 300)
CCPConnections <- ConnectToVirtualCCP(CCPTestData = CCPTestData_Total,
NumberOfSites = 3,
NumberOfPatientsPerSite = 300000)
devtools::load_all(".")
CCPConnections <- ConnectToVirtualCCP(CCPTestData = CCPTestData_Total,
NumberOfSites = 3,
NumberOfPatientsPerSite = 300)
# For testing purposes
DataSources <- CCPConnections
# Get info about installed packages on servers
DSI::datashield.pkg_status(conns = DataSources)
# Get data frame of available AGGREGATE functions
DSI::datashield.method_status(conns = DataSources,
type = "aggregate")
# Get data frame of available ASSIGN functions
DSI::datashield.method_status(conns = DataSources,
type = "assign")
FunctionsOnServer <- rbind(# Get data frame of available AGGREGATE functions
DSI::datashield.method_status(conns = DataSources,
type = "aggregate"),
# Get data frame of available ASSIGN functions
DSI::datashield.method_status(conns = DataSources,
type = "assign"))
View(FunctionsOnServer)
?join_by
Join <- FunctionsOnServer %>%
left_join(RequiredFunctions, by = join_by(name == FunctionName, type == FunctionType))
RequiredFunctions = dsCCPhosClient::Meta_RequiredCCPhosFunctions
Join <- FunctionsOnServer %>%
left_join(RequiredFunctions, by = join_by(name == FunctionName, type == FunctionType))
View(Join)
Join <- RequiredFunctions %>%
left_join(FunctionsOnServer, by = join_by(name == FunctionName, type == FunctionType))
Join <- RequiredFunctions %>%
left_join(FunctionsOnServer, by = join_by(FunctionName == name, FunctionType == type))
View(Join)
# Get info about installed packages on servers
DSI::datashield.pkg_status(conns = DataSources)
# Get info about installed packages on servers
PackageAvailability <- DSI::datashield.pkg_status(conns = DataSources)
PackageAvailability$package_status
Test <- PackageAvailability$package_status
Test <- as.data.frame(PackageAvailability$package_status)
View(Test)
?as.data.frame
Meta_ServerRequirements <- list(#--- Data frame containing names of required packages ---
PackageAvailability = data.frame(PackageName = character()) %>%
add_row(PackageName = "dsBase") %>%
add_row(PackageName = "dsCCPhos"),
#--- Data frame containing names and types of required functions ---
FunctionAvailability = data.frame(FunctionName = character(),
FunctionType = character()) %>%
add_row(FunctionName = "GetCurationReportDS", FunctionType = "aggregate") %>%
add_row(FunctionName = "AugmentDataDS", FunctionType = "assign") %>%
add_row(FunctionName = "CurateDataDS", FunctionType = "assign") %>%
add_row(FunctionName = "UnpackAugmentedDataSetDS", FunctionType = "assign") %>%
add_row(FunctionName = "UnpackCuratedDataSetDS", FunctionType = "assign"))
Meta_ServerRequirements$PackageAvailability
# Save data in .rda-file and make it part of package
use_data(Meta_ServerRequirements, overwrite = TRUE)
library(usethis)
# Save data in .rda-file and make it part of package
use_data(Meta_ServerRequirements, overwrite = TRUE)
devtools::load_all(".")
Meta_ServerRequirements <- list(#--- Data frame containing names of required packages ---
RequiredPackages = data.frame(PackageName = character()) %>%
add_row(PackageName = "dsBase") %>%
add_row(PackageName = "dsCCPhos"),
#--- Data frame containing names and types of required functions ---
RequiredFunctions = data.frame(FunctionName = character(),
FunctionType = character()) %>%
add_row(FunctionName = "GetCurationReportDS", FunctionType = "aggregate") %>%
add_row(FunctionName = "AugmentDataDS", FunctionType = "assign") %>%
add_row(FunctionName = "CurateDataDS", FunctionType = "assign") %>%
add_row(FunctionName = "UnpackAugmentedDataSetDS", FunctionType = "assign") %>%
add_row(FunctionName = "UnpackCuratedDataSetDS", FunctionType = "assign"))
# Save data in .rda-file and make it part of package
use_data(Meta_ServerRequirements, overwrite = TRUE)
devtools::load_all(".")
# For testing purposes
DataSources <- CCPConnections
ServerRequirements <- dsCCPhosClient::Meta_ServerRequirements
# Get info about installed packages on servers
PackageAvailability <- DSI::datashield.pkg_status(conns = DataSources)
PackageAvailability
?left_join
# Get info about installed server packages
PackageAvailability <- as_tibble(DSI::datashield.pkg_status(conns = DataSources))
PackageAvailability
# Get info about installed server packages
PackageAvailability <- as_tibble(DSI::datashield.pkg_status(conns = DataSources)$package_status)
View(PackageAvailability)
?as_tibble
# Get info about installed server packages
PackageAvailability <- as_tibble(DSI::datashield.pkg_status(conns = DataSources)$package_status,
rownames = "PackageName")
View(PackageAvailability)
RequiredPackageAvailability <- ServerRequirements$RequiredPackages %>%
left_join(PackageAvailability, by = join_by(PackageName))
View(RequiredPackageAvailability)
VersionOfdsCCPhos <- DSI::datashield.pkg_status(conns = DataSources)$version_status["dsCCPhos"]
VersionOfdsCCPhos <- DSI::datashield.pkg_status(conns = DataSources)$version_status[, "dsCCPhos"]
VersionOfdsCCPhos <- DSI::datashield.pkg_status(conns = DataSources)$version_status
VersionOfdsCCPhos
VersionOfdsCCPhos <- as_tibble(DSI::datashield.pkg_status(conns = DataSources)$version_status,
rownames = "PackageName")
View(VersionOfdsCCPhos)
VersionOfdsCCPhos <- as_tibble(DSI::datashield.pkg_status(conns = DataSources)$version_status,
rownames = "PackageName") %>%
filter(PackageName == "dsCCPhos")
View(PackageAvailability)
View(RequiredPackageAvailability)
View(RequiredPackageAvailability)
?c_across
# For testing purposes
DataSources <- CCPConnections
ServerRequirements <- dsCCPhosClient::Meta_ServerRequirements
# Get server names
ServerNames <- names(DataSources)
# Get info about installed server packages
PackageAvailability <- as_tibble(DSI::datashield.pkg_status(conns = DataSources)$package_status,
rownames = "PackageName")
# Check if defined set of packages is available on all servers
RequiredPackageAvailability <- ServerRequirements$RequiredPackages %>%
left_join(PackageAvailability, by = join_by(PackageName)) %>%
rowwise() %>%
mutate(IsAvailableEverywhere = all(c_across(ServerNames) == TRUE))
View(RequiredPackageAvailability)
# Check if defined set of packages is available on all servers
RequiredPackageAvailability <- ServerRequirements$RequiredPackages %>%
left_join(PackageAvailability, by = join_by(PackageName)) %>%
rowwise() %>%
mutate(IsAvailableEverywhere = all(c_across(ServerNames) == TRUE),
NotAvailableAt = SeverNames[!c_across(ServerNames) == FALSE])
# Check if defined set of packages is available on all servers
RequiredPackageAvailability <- ServerRequirements$RequiredPackages %>%
left_join(PackageAvailability, by = join_by(PackageName)) %>%
rowwise() %>%
mutate(IsAvailableEverywhere = all(c_across(ServerNames) == TRUE),
NotAvailableAt = ServerNames[!c_across(ServerNames) == FALSE])
# Check if defined set of packages is available on all servers
RequiredPackageAvailability <- ServerRequirements$RequiredPackages %>%
left_join(PackageAvailability, by = join_by(PackageName)) %>%
rowwise() %>%
mutate(IsAvailableEverywhere = all(c_across(ServerNames) == TRUE),
NotAvailableAt = ServerNames[c_across(ServerNames) == FALSE])
# Check if defined set of packages is available on all servers
RequiredPackageAvailability <- ServerRequirements$RequiredPackages %>%
left_join(PackageAvailability, by = join_by(PackageName)) %>%
rowwise() %>%
mutate(IsAvailableEverywhere = all(c_across(ServerNames) == TRUE),
NotAvailableAt = ifelse(IsAvailableEverywhere == FALSE,
paste0(ServerNames[c_across(ServerNames) == FALSE], collapse = ", "),
NA))
View(RequiredPackageAvailability)
View(PackageAvailability)
# Check if defined set of packages is available on all servers
RequiredPackageAvailability <- ServerRequirements$RequiredPackages %>%
add_row(PackageName = "Test") %>%
left_join(PackageAvailability, by = join_by(PackageName)) %>%
rowwise() %>%
mutate(IsAvailableEverywhere = all(c_across(ServerNames) == TRUE),
NotAvailableAt = ifelse(IsAvailableEverywhere == FALSE,
paste0(ServerNames[c_across(ServerNames) == FALSE], collapse = ", "),
NA))
View(RequiredPackageAvailability)
# Check if defined set of packages is available on all servers
RequiredPackageAvailability <- ServerRequirements$RequiredPackages %>%
left_join(PackageAvailability, by = join_by(PackageName)) %>%
add_row(PackageName = "Test", SiteA = FALSE, SiteB = TRUE, SiteC = FALSE) %>%
rowwise() %>%
mutate(IsAvailableEverywhere = all(c_across(ServerNames) == TRUE),
NotAvailableAt = ifelse(IsAvailableEverywhere == FALSE,
paste0(ServerNames[c_across(ServerNames) == FALSE], collapse = ", "),
NA))
View(RequiredPackageAvailability)
# Check if defined set of packages is available on all servers
RequiredPackageAvailability <- ServerRequirements$RequiredPackages %>%
left_join(PackageAvailability, by = join_by(PackageName)) %>%
add_row(PackageName = "Test", SiteA = FALSE, SiteB = TRUE, SiteC = TRUE) %>%
rowwise() %>%
mutate(IsAvailableEverywhere = all(c_across(ServerNames) == TRUE),
NotAvailableAt = ifelse(IsAvailableEverywhere == FALSE,
paste0(ServerNames[c_across(ServerNames) == FALSE], collapse = ", "),
NA))
View(RequiredPackageAvailability)
# Check if defined set of packages is available on all servers
RequiredPackageAvailability <- ServerRequirements$RequiredPackages %>%
add_row(PackageName = "Test") %>%
left_join(PackageAvailability, by = join_by(PackageName)) %>%
rowwise() %>%
mutate(across(ServerNames, ~ ifelse(is.na(.), FALSE, .)),
IsAvailableEverywhere = all(c_across(ServerNames) == TRUE),
NotAvailableAt = ifelse(IsAvailableEverywhere == FALSE,
paste0(ServerNames[c_across(ServerNames) == FALSE], collapse = ", "),
NA)) %>%
ungroup()
View(RequiredPackageAvailability)
Row <- RequiredPackageAvailability[i, ]
View(Row)
Row <- RequiredPackageAvailability[2, ]
View(Row)
# For testing purposes
DataSources <- CCPConnections
ServerRequirements <- dsCCPhosClient::Meta_ServerRequirements
# Get server names
ServerNames <- names(DataSources)
# Get info about installed server packages
PackageAvailability <- as_tibble(DSI::datashield.pkg_status(conns = DataSources)$package_status,
rownames = "PackageName")
# Check if defined set of packages is available on all servers
RequiredPackageAvailability <- ServerRequirements$RequiredPackages %>%
left_join(PackageAvailability, by = join_by(PackageName)) %>%
rowwise() %>%
mutate(across(ServerNames, ~ ifelse(is.na(.), FALSE, .)),      # Replace NA values with FALSE. NA is introduced when a required package is not listed in 'PackageAvailability'.
IsAvailableEverywhere = all(c_across(ServerNames) == TRUE),
NotAvailableAt = ifelse(IsAvailableEverywhere == FALSE,
paste0(ServerNames[c_across(ServerNames) == FALSE], collapse = ", "),
NA)) %>%
ungroup()
for (i in 1:nrow(RequiredPackageAvailability))
{
Row <- RequiredPackageAvailability[i, ]
cat("Package ",
Row$PackageName,
ifelse(Row$IsAvailableEverywhere == TRUE,
" is available on all servers!\n",
paste0(" is not available on ", Row$NotAvailableAt)))
}
for (i in 1:nrow(RequiredPackageAvailability))
{
Row <- RequiredPackageAvailability[i, ]
cat("Package",
Row$PackageName,
ifelse(Row$IsAvailableEverywhere == TRUE,
"is available on all servers!\n",
paste0("is not available on ", Row$NotAvailableAt)))
}
# Check if defined set of packages is available on all servers
RequiredPackageAvailability <- ServerRequirements$RequiredPackages %>%
add_row(PackageName = "Test") %>%
left_join(PackageAvailability, by = join_by(PackageName)) %>%
rowwise() %>%
mutate(across(ServerNames, ~ ifelse(is.na(.), FALSE, .)),      # Replace NA values with FALSE. NA is introduced when a required package is not listed in 'PackageAvailability'.
IsAvailableEverywhere = all(c_across(ServerNames) == TRUE),
NotAvailableAt = ifelse(IsAvailableEverywhere == FALSE,
paste0(ServerNames[c_across(ServerNames) == FALSE], collapse = ", "),
NA)) %>%
ungroup()
for (i in 1:nrow(RequiredPackageAvailability))
{
Row <- RequiredPackageAvailability[i, ]
cat("Package",
Row$PackageName,
ifelse(Row$IsAvailableEverywhere == TRUE,
"is available on all servers!\n",
paste0("is not available on ", Row$NotAvailableAt)))
}
# Initiate output message object
Messages <- list()
Messages$PackageAvailability <- list()
Messages$VersionOfdsCCPhos <- list()
Messages$FunctionAvailability <- list()
# Initiate output message object
Messages <- list()
Messages$PackageAvailability <- list()
Messages$VersionOfdsCCPhos <- list()
Messages$FunctionAvailability <- list()
# Get server names
ServerNames <- names(DataSources)
# Get info about installed server packages
PackageAvailability <- as_tibble(DSI::datashield.pkg_status(conns = DataSources)$package_status,
rownames = "PackageName")
# Check if defined set of packages is available on all servers
RequiredPackageAvailability <- ServerRequirements$RequiredPackages %>%
left_join(PackageAvailability, by = join_by(PackageName)) %>%
rowwise() %>%
mutate(across(ServerNames, ~ ifelse(is.na(.), FALSE, .)),      # Replace NA values with FALSE. NA is introduced when a required package is not listed in 'PackageAvailability'.
IsAvailableEverywhere = all(c_across(ServerNames) == TRUE),
NotAvailableAt = ifelse(IsAvailableEverywhere == FALSE,
paste0(ServerNames[c_across(ServerNames) == FALSE], collapse = ", "),
NA)) %>%
ungroup()
# Compile output message concerning package availability
for (i in 1:nrow(RequiredPackageAvailability))
{
Row <- RequiredPackageAvailability[i, ]
Message <- paste0("Package ",
Row$PackageName,
ifelse(Row$IsAvailableEverywhere == TRUE,
" is available on all servers!\n",
paste0(" is not available on ", Row$NotAvailableAt)))
Message$PackageAvailability <- c(Message$PackageAvailability,
Message)
}
# Initiate output message object
Messages <- list()
Messages$PackageAvailability <- character()
Messages$VersionOfdsCCPhos <- character()
Messages$FunctionAvailability <- character()
# Get server names
ServerNames <- names(DataSources)
# Get info about installed server packages
PackageAvailability <- as_tibble(DSI::datashield.pkg_status(conns = DataSources)$package_status,
rownames = "PackageName")
# Check if defined set of packages is available on all servers
RequiredPackageAvailability <- ServerRequirements$RequiredPackages %>%
left_join(PackageAvailability, by = join_by(PackageName)) %>%
rowwise() %>%
mutate(across(ServerNames, ~ ifelse(is.na(.), FALSE, .)),      # Replace NA values with FALSE. NA is introduced when a required package is not listed in 'PackageAvailability'.
IsAvailableEverywhere = all(c_across(ServerNames) == TRUE),
NotAvailableAt = ifelse(IsAvailableEverywhere == FALSE,
paste0(ServerNames[c_across(ServerNames) == FALSE], collapse = ", "),
NA)) %>%
ungroup()
# Compile output message concerning package availability
for (i in 1:nrow(RequiredPackageAvailability))
{
Row <- RequiredPackageAvailability[i, ]
Message <- paste0("Package ",
Row$PackageName,
ifelse(Row$IsAvailableEverywhere == TRUE,
" is available on all servers!\n",
paste0(" is not available on ", Row$NotAvailableAt)))
Message$PackageAvailability <- c(Message$PackageAvailability,
Message)
}
# Compile output message concerning package availability
for (i in 1:nrow(RequiredPackageAvailability))
{
Row <- RequiredPackageAvailability[i, ]
Message <- paste0("Package ",
Row$PackageName,
ifelse(Row$IsAvailableEverywhere == TRUE,
" is available on all servers!\n",
paste0(" is not available on ", Row$NotAvailableAt)))
Message$PackageAvailability <- append(Message$PackageAvailability,
Message)
}
# Compile output message concerning package availability
for (i in 1:nrow(RequiredPackageAvailability))
{
Row <- RequiredPackageAvailability[i, ]
Message <- paste0("Package ",
Row$PackageName,
ifelse(Row$IsAvailableEverywhere == TRUE,
" is available on all servers!\n",
paste0(" is not available on ", Row$NotAvailableAt)))
Messages$PackageAvailability <- c(Messages$PackageAvailability,
Message)
}
# Get version number of dsCCPhos on all servers
VersionOfdsCCPhos <- as_tibble(DSI::datashield.pkg_status(conns = DataSources)$version_status,
rownames = "PackageName") %>%
filter(PackageName == "dsCCPhos")
View(VersionOfdsCCPhos)
?apply
?all
View(VersionOfdsCCPhos)
# Get version number of dsCCPhos on all servers and check for equality
VersionOfdsCCPhos <- as_tibble(DSI::datashield.pkg_status(conns = DataSources)$version_status,
rownames = "PackageName") %>%
filter(PackageName == "dsCCPhos") %>%
select(-PackageName)
View(VersionOfdsCCPhos)
IsEqualEverywhere <- apply(VersionOfdsCCPhos, 1, function(Values) { all(Values == Values[1]) })
names(VersionOfdsCCPhos)
names(VersionOfdsCCPhos)[1]
VersionOfdsCCPhos[, 2]
VersionOfdsCCPhos[[, 2]]
paste0("Test", VersionOfdsCCPhos[, 2])
# Get coherent data frame of general function availability on all servers
FunctionAvailability <- rbind(# Get data frame of available AGGREGATE functions
DSI::datashield.method_status(conns = DataSources,
type = "aggregate"),
# Get data frame of available ASSIGN functions
DSI::datashield.method_status(conns = DataSources,
type = "assign"))
# Check if defined set of required functions is available on all servers
RequiredFunctionAvailability <- ServerRequirements$RequiredFunctions %>%
left_join(FunctionAvailability, by = join_by(FunctionName == name, FunctionType == type))
View(RequiredFunctionAvailability)
DataSources <- CCPConnections
ServerRequirements <- dsCCPhosClient::Meta_ServerRequirements
# Initiate output messaging objects
Messages <- list()
Messages$PackageAvailability <- character()
Messages$VersionOfdsCCPhos <- character()
Messages$FunctionAvailability <- character()
# Get server names
ServerNames <- names(DataSources)
# Package availability on servers
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Get info about installed server packages
PackageAvailability <- as_tibble(DSI::datashield.pkg_status(conns = DataSources)$package_status,
rownames = "PackageName")
# Check if defined set of packages is available on all servers
RequiredPackageAvailability <- ServerRequirements$RequiredPackages %>%
left_join(PackageAvailability, by = join_by(PackageName)) %>%
rowwise() %>%
mutate(across(ServerNames, ~ ifelse(is.na(.), FALSE, .)),      # Replace NA values with FALSE. NAs are introduced when a required package is not listed in 'PackageAvailability'.
IsAvailableEverywhere = all(c_across(ServerNames) == TRUE),
NotAvailableAt = ifelse(IsAvailableEverywhere == FALSE,
paste0(ServerNames[c_across(ServerNames) == FALSE], collapse = ", "),
NA)) %>%
ungroup()
# Compile output message concerning one package each and add it to Messages
for (i in 1:nrow(RequiredPackageAvailability))
{
Row <- RequiredPackageAvailability[i, ]
Message <- paste0("Package ",
Row$PackageName,
ifelse(Row$IsAvailableEverywhere == TRUE,
" is available on all servers!",
paste0(" is not available on ", Row$NotAvailableAt)))
Messages$PackageAvailability <- c(Messages$PackageAvailability,
Message)
}
# Available version of dsCCPhos
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Get version number of dsCCPhos on all servers and check for equality
VersionOfdsCCPhos <- as_tibble(DSI::datashield.pkg_status(conns = DataSources)$version_status,
rownames = "PackageName") %>%
filter(PackageName == "dsCCPhos") %>%
select(-PackageName)
IsEqualEverywhere <- apply(VersionOfdsCCPhos, 1, function(Values) { all(Values == Values[1]) })
if (IsEqualEverywhere == TRUE)
{
Messages$VersionOfdsCCPhos <- paste0("Version of dsCCPhos is equal on all servers (Ver. ", VersionOfdsCCPhos[1, 1], ")!")
} else {
Messages$VersionOfdsCCPhos <- paste0("Version of dsCCPhos varies between servers!")
for (i in 1:ncol(VersionOfdsCCPhos))
{
Messages$VersionOfdsCCPhos <- c(Messages$VersionOfdsCCPhos,
paste0(names(VersionOfdsCCPhos)[i], ": Ver. ", VersionOfdsCCPhos[, i]))
}
}
# Function availability on servers
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Get coherent data frame of general function availability on all servers
FunctionAvailability <- rbind(# Get data frame of available AGGREGATE functions
DSI::datashield.method_status(conns = DataSources,
type = "aggregate"),
# Get data frame of available ASSIGN functions
DSI::datashield.method_status(conns = DataSources,
type = "assign"))
# Check if defined set of required functions is available on all servers
RequiredFunctionAvailability <- ServerRequirements$RequiredFunctions %>%
left_join(FunctionAvailability, by = join_by(FunctionName == name, FunctionType == type)) %>%
rowwise() %>%
mutate(across(ServerNames, ~ ifelse(is.na(.), FALSE, .)),      # Replace NA values with FALSE. NAs are introduced when a required function is not listed in 'FunctionAvailability'.
IsAvailableEverywhere = all(c_across(ServerNames) == TRUE),
NotAvailableAt = ifelse(IsAvailableEverywhere == FALSE,
paste0(ServerNames[c_across(ServerNames) == FALSE], collapse = ", "),
NA)) %>%
ungroup()
# Compile output message concerning one function each and add it to Messages
for (i in 1:nrow(RequiredFunctionAvailability))
{
Row <- RequiredFunctionAvailability[i, ]
Message <- paste0("Function ",
Row$FunctionName,
ifelse(Row$IsAvailableEverywhere == TRUE,
" is available on all servers!",
paste0(" is not available on ", Row$NotAvailableAt)))
Messages$FunctionAvailability <- c(Messages$FunctionAvailability,
Message)
}
cat(Messages)
print(Messages)
cat(paste0(unlist(Messages), collapse = "\n"))
devtools::load_all(".")
library(dsCCPhosClient)
# Load needed packages
library(dsBase)
library(dsBaseClient)
library(dsCCPhos)
library(dsCCPhosClient)
library(DSLite)
load("../dsCCPhos/Development/Data/TestData/CCPTestData_Total.RData")
CCPConnections <- ConnectToVirtualCCP(CCPTestData = CCPTestData_Total,
NumberOfSites = 3,
NumberOfPatientsPerSite = 300)
CheckServerRequirements(DataSources = CCPConnections)
MessagesServerRequirements <- CheckServerRequirements(DataSources = CCPConnections)
# Get overview of accessible tables on servers
DSI::datashield.tables(conns = CCPConnections)
library(devtools)
# General / Auxiliary functions
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# use_r("CheckServerRequirements.R")
# use_r("ConnectToCCP.R")
# use_r("ConnectToVirtualCCP.R")
use_r("LoadRawDataSet.R")
