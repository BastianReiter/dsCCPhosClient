library(dsCCPhosClient)
library(dsTidyverseClient)
library(resourcer)
# Print DataSHIELD errors right away
options(datashield.errors.print = TRUE)
#TestData <- readRDS("../dsCCPhos/Development/Data/RealData/CCPRealData_Frankfurt.rds")
TestData <- readRDS("../dsCCPhos/Development/Data/TestData/CCPTestData.rds")
# Definition of test resource, exemplary with local csv-file
TestResource <- resourcer::newResource(name = "TestResource",
#url = "file://./Development/Test/DummyData.csv",
url = "file://localhost/C:/Users/Basti/ARBEIT Lokal/dsCCPhosClient/Development/Test/DummyData.csv",
format = "csv")
CCPConnections <- ConnectToVirtualCCP(CCPTestData = TestData,
NumberOfServers = 3,
NumberOfPatientsPerServer = 2000,
AddedDsPackages = "dsTidyverse",
Resources = list(TestResource = TestResource))
LoadRawDataSet(ServerSpecifications = NULL)
# Transform Raw Data Set (RDS) into Curated Data Set (CDS) (using default settings)
ds.CurateData(RawDataSetName = "RawDataSet",
Settings = NULL,
OutputName = "CurationOutput")
# Run ds.AugmentData
ds.AugmentData(CuratedDataSetName = "CuratedDataSet",
OutputName = "AugmentationOutput")
# --- For Testing Purposes ---
TableName <- "ADS_Patient"
FeatureNames <- c("Gender", "CountDiagnoses")
DSConnections <- CCPConnections
require(DSI)
require(purrr)
CrossTables <- DSI::datashield.aggregate(conns = DSConnections,
expr = call("GetCrossTableDS",
TableName.S = TableName,
FeatureNames.S = FeatureNames))
call("GetCrossTableDS",
TableName.S = TableName,
FeatureNames.S = FeatureNames)
?trace
trace("aggregateDS", where = "package:DSLite")
?DSLite::dsAggregate()
trace("dsAggregate", where = "package:DSLite")
trace(sum)
hist(rnorm(100)) # shows about 3-4 calls to sum()
untrace(sum)
trace("aggregateDS", where = asNamespace("DSLite"),
tracer = quote({
cat("\n[DSLite] aggregateDS() received expr:\n")
print(expr)
cat("[DSLite] evaluating in server context...\n")
}))
DSConnections$ServerA
trace("aggregate", where = asNamespace("DSLite"),
tracer = quote({
cat("\n[DSLite] aggregateDS() received expr:\n")
print(expr)
cat("[DSLite] evaluating in server context...\n")
}))
trace("aggregate", where = "package:DSLite",
tracer = quote({
cat("\n[DSLite] aggregateDS() received expr:\n")
print(expr)
cat("[DSLite] evaluating in server context...\n")
}))
devtools::load_all(".")
library(dsBaseClient)
library(dsCCPhosClient)
library(dsTidyverseClient)
library(resourcer)
# Print DataSHIELD errors right away
options(datashield.errors.print = TRUE)
#TestData <- readRDS("../dsCCPhos/Development/Data/RealData/CCPRealData_Frankfurt.rds")
TestData <- readRDS("../dsCCPhos/Development/Data/TestData/CCPTestData.rds")
# Definition of test resource, exemplary with local csv-file
TestResource <- resourcer::newResource(name = "TestResource",
#url = "file://./Development/Test/DummyData.csv",
url = "file://localhost/C:/Users/Basti/ARBEIT Lokal/dsCCPhosClient/Development/Test/DummyData.csv",
format = "csv")
CCPConnections <- ConnectToVirtualCCP(CCPTestData = TestData,
NumberOfServers = 3,
NumberOfPatientsPerServer = 2000,
AddedDsPackages = "dsTidyverse",
Resources = list(TestResource = TestResource))
LoadRawDataSet(ServerSpecifications = NULL)
# Transform Raw Data Set (RDS) into Curated Data Set (CDS) (using default settings)
ds.CurateData(RawDataSetName = "RawDataSet",
Settings = NULL,
OutputName = "CurationOutput")
# Run ds.AugmentData
ds.AugmentData(CuratedDataSetName = "CuratedDataSet",
OutputName = "AugmentationOutput")
require(DSI)
require(purrr)
# --- For Testing Purposes ---
TableName <- "ADS_Patient"
FeatureNames <- "Sex, CountDiagnoses"
DSConnections <- CCPConnections
# Check validity of 'DSConnections' or find them programmatically if none are passed
DSConnections <- CheckDSConnections(DSConnections)
CrossTables <- DSI::datashield.aggregate(conns = DSConnections,
expr = call("GetCrossTableDS",
TableName.S = TableName,
FeatureNames.S = FeatureNames))
# Encode string in 'FeatureNames' to make it passable through DSI
FeatureNames <- .encode_tidy_eval(FeatureNames, .get_encode_dictionary())
CrossTables <- DSI::datashield.aggregate(conns = DSConnections,
expr = call("GetCrossTableDS",
TableName.S = TableName,
FeatureNames.S = FeatureNames))
CrossTables$ServerA$CrossTable
FeatureNames <- c("Sex", "CountDiagnoses")
# Encode string in 'FeatureNames' to make it passable through DSI
FeatureNames <- paste0(FeatureNames, collapse = ", ") %>%
.encode_tidy_eval(FeatureNames, .get_encode_dictionary())
# Encode string in 'FeatureNames' to make it passable through DSI
FeatureNames <- paste0(FeatureNames, collapse = ", ") %>%
.encode_tidy_eval(.get_encode_dictionary())
CrossTables <- DSI::datashield.aggregate(conns = DSConnections,
expr = call("GetCrossTableDS",
TableName.S = TableName,
FeatureNames.S = FeatureNames))
CrossTables$ServerA$ChiSq.PValue
XTab.Cumulated <- CrossTables %>%
list_transpose()
XTab.Cumulated$ChiSq.PValue
?list_transpose
XTab.Cumulated <- CrossTables %>%
list_transpose(simplify = FALSE)
XTab.Cumulated$ChiSq.PValue
# Call server-side function
ServerReturns <- DSI::datashield.aggregate(conns = DSConnections,
expr = call("GetCrossTableDS",
TableName.S = TableName,
FeatureNames.S = FeatureNames))
CrossTables <- ServerReturns %>%
list_transpose(simplify = FALSE) %>%
pluck(CrossTable)
# Call server-side function
ServerReturns <- DSI::datashield.aggregate(conns = DSConnections,
expr = call("GetCrossTableDS",
TableName.S = TableName,
FeatureNames.S = FeatureNames))
CrossTables <- ServerReturns %>%
list_transpose(simplify = FALSE) %>%
pluck(CrossTable)
CrossTables <- ServerReturns %>%
list_transpose(simplify = FALSE) %>%
pluck("CrossTable")
CrossTables.Separate <- ServerReturns %>%
list_transpose(simplify = FALSE) %>%
pluck("CrossTable") %>%
list_rbind(names_to = "Server")
View(CrossTables.Separate)
CrossTable.Separate <- ServerReturns %>%
list_transpose(simplify = FALSE) %>%
pluck("CrossTable") %>%
list_rbind(names_to = "Server")
FeatureNames <- c("Sex", "CountDiagnoses")
FeatureNames <- c("Sex", "CountDiagnoses")
CrossTable.Cumulated <- CrossTable.Separate %>%
group_by(all_of(FeatureNames)) %>%
summarize(Server = "All",
Count = sum(Count, na.rm = TRUE),
ServersBelowThreshold = sum(BelowThreshold == TRUE))
all_of(FeatureNames)
CrossTable.Cumulated <- CrossTable.Separate %>%
group_by(FeatureNames) %>%
summarize(Server = "All",
Count = sum(Count, na.rm = TRUE),
ServersBelowThreshold = sum(BelowThreshold == TRUE))
CrossTable.Cumulated <- CrossTable.Separate %>%
group_by(all_of(FeatureNames)) %>%
summarize(Server = "All",
Count = sum(Count, na.rm = TRUE),
ServersBelowThreshold = sum(BelowThreshold == TRUE))
CrossTable.Cumulated <- CrossTable.Separate %>%
group_by(across(all_of(FeatureNames))) %>%
summarize(Server = "All",
Count = sum(Count, na.rm = TRUE),
ServersBelowThreshold = sum(BelowThreshold == TRUE))
View(CrossTable.Separate)
CrossTable.Cumulated <- CrossTable.Separate %>%
group_by(across(all_of(FeatureNames))) %>%
summarize(Server = "All",
Count = sum(Count, na.rm = TRUE),
ServersBelowThreshold = sum(NBelowThreshold == TRUE))
View(CrossTable.Cumulated)
CrossTable <- CrossTable.Cumulated %>%
bind_rows(CrossTable.Separate)
View(CrossTable)
library(dsBaseClient)
library(dsCCPhosClient)
library(dsTidyverseClient)
library(resourcer)
# Print DataSHIELD errors right away
options(datashield.errors.print = TRUE)
#TestData <- readRDS("../dsCCPhos/Development/Data/RealData/CCPRealData_Frankfurt.rds")
TestData <- readRDS("../dsCCPhos/Development/Data/TestData/CCPTestData.rds")
# Definition of test resource, exemplary with local csv-file
TestResource <- resourcer::newResource(name = "TestResource",
#url = "file://./Development/Test/DummyData.csv",
url = "file://localhost/C:/Users/Basti/ARBEIT Lokal/dsCCPhosClient/Development/Test/DummyData.csv",
format = "csv")
CCPConnections <- ConnectToVirtualCCP(CCPTestData = TestData,
NumberOfServers = 3,
NumberOfPatientsPerServer = 2000,
AddedDsPackages = "dsTidyverse",
Resources = list(TestResource = TestResource))
LoadRawDataSet(ServerSpecifications = NULL)
# Transform Raw Data Set (RDS) into Curated Data Set (CDS) (using default settings)
ds.CurateData(RawDataSetName = "RawDataSet",
Settings = NULL,
OutputName = "CurationOutput")
# Run ds.AugmentData
ds.AugmentData(CuratedDataSetName = "CuratedDataSet",
OutputName = "AugmentationOutput")
library(dsBaseClient)
library(dsCCPhosClient)
library(dsTidyverseClient)
library(resourcer)
# Print DataSHIELD errors right away
options(datashield.errors.print = TRUE)
#TestData <- readRDS("../dsCCPhos/Development/Data/RealData/CCPRealData_Frankfurt.rds")
TestData <- readRDS("../dsCCPhos/Development/Data/TestData/CCPTestData.rds")
# Definition of test resource, exemplary with local csv-file
TestResource <- resourcer::newResource(name = "TestResource",
#url = "file://./Development/Test/DummyData.csv",
url = "file://localhost/C:/Users/Basti/ARBEIT Lokal/dsCCPhosClient/Development/Test/DummyData.csv",
format = "csv")
CCPConnections <- ConnectToVirtualCCP(CCPTestData = TestData,
NumberOfServers = 3,
NumberOfPatientsPerServer = 2000,
AddedDsPackages = "dsTidyverse",
Resources = list(TestResource = TestResource))
LoadRawDataSet(ServerSpecifications = NULL)
# Transform Raw Data Set (RDS) into Curated Data Set (CDS) (using default settings)
ds.CurateData(RawDataSetName = "RawDataSet",
Settings = NULL,
OutputName = "CurationOutput")
# Run ds.AugmentData
ds.AugmentData(CuratedDataSetName = "CuratedDataSet",
OutputName = "AugmentationOutput")
require(DSI)
require(purrr)
# --- For Testing Purposes ---
TableName <- "ADS_Patient"
FeatureNames <- c("Sex", "CountDiagnoses")
DSConnections <- CCPConnections
# Argument assertions
assert_that(is.string(TableName),
is.character(FeatureNames))
library(devtools)
library(dplyr)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Adding package dependencies using usethis::use_package()
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
use_package("assertthat")
require(assertthat)
# Argument assertions
assert_that(is.string(TableName),
is.character(FeatureNames))
# Paste elements of 'FeatureNames' together and encode the resulting string to make it passable through DSI
FeatureNamesString <- paste0(FeatureNames, collapse = ", ") %>%
.encode_tidy_eval(.get_encode_dictionary())
devtools::load_all(".")
# Paste elements of 'FeatureNames' together and encode the resulting string to make it passable through DSI
FeatureNamesString <- paste0(FeatureNames, collapse = ", ") %>%
.encode_tidy_eval(.get_encode_dictionary())
# Call server-side function
ServerReturns <- DSI::datashield.aggregate(conns = DSConnections,
expr = call("GetCrossTabDS",
TableName.S = TableName,
FeatureNames.S = FeatureNamesString))
CrossTab.Separate <- ServerReturns %>%
list_transpose(simplify = FALSE) %>%
pluck("CrossTable") %>%
list_rbind(names_to = "Server")
# Call server-side function
ServerReturns <- DSI::datashield.aggregate(conns = DSConnections,
expr = call("GetCrossTabDS",
TableName.S = TableName,
FeatureNames.S = FeatureNamesString))
CrossTab.Separate <- ServerReturns %>%
list_transpose(simplify = FALSE) %>%
pluck("CrossTable") %>%
list_rbind(names_to = "Server")
CrossTab.Separate <- ServerReturns %>%
list_transpose(simplify = FALSE) %>%
pluck("CrossTab") %>%
list_rbind(names_to = "Server")
CrossTab.Separate <- ServerReturns %>%
list_transpose(simplify = FALSE) %>%
pluck("CrossTab") %>%
list_rbind(names_to = "Server")
CrossTab.Cumulated <- CrossTab.Separate %>%
group_by(across(all_of(FeatureNames))) %>%
summarize(Server = "All",
Count = sum(Count, na.rm = TRUE),
ServersBelowThreshold = sum(NBelowThreshold == TRUE))
CrossTab <- CrossTab.Cumulated %>%
bind_rows(CrossTab.Separate)
View(CrossTab)
Test <- ds.GetFeatureInfo(TableName = TableName,
FeatureName = "Sex")
rm(DSConnections)
Test <- ds.GetFeatureInfo(TableName = TableName,
FeatureName = "Sex")
Test$CountUniqueValues
Test
?sapply
Test <- sapply(FeatureNames, function(featurename) { ds.GetFeatureInfo(TableName = TableName,
FeatureName = featurename) })
Test <- sapply(FeatureNames, function(featurename) { ds.GetFeatureInfo(TableName = TableName,
FeatureName = featurename) %>%
max(.$CountUniqueValues) })
?max
Test <- sapply(FeatureNames, function(featurename) { ds.GetFeatureInfo(TableName = TableName,
FeatureName = featurename) %>%
pull(CountUniqueValues) %>%
max(na.rm = TRUE)})
Test
Test <- lapply(FeatureNames, function(featurename) { ds.GetFeatureInfo(TableName = TableName,
FeatureName = featurename) %>%
pull(CountUniqueValues) %>%
max(na.rm = TRUE)})
Test
Test <- sapply(FeatureNames, function(featurename) { ds.GetFeatureInfo(TableName = TableName,
FeatureName = featurename) %>%
pull(CountUniqueValues) %>%
max(na.rm = TRUE)})
Test
prod(Test, na.rm = TRUE)
?stop
View(CrossTab)
library(dsBaseClient)
library(dsCCPhosClient)
library(dsTidyverseClient)
library(resourcer)
# Print DataSHIELD errors right away
options(datashield.errors.print = TRUE)
#TestData <- readRDS("../dsCCPhos/Development/Data/RealData/CCPRealData_Frankfurt.rds")
TestData <- readRDS("../dsCCPhos/Development/Data/TestData/CCPTestData.rds")
# Definition of test resource, exemplary with local csv-file
TestResource <- resourcer::newResource(name = "TestResource",
#url = "file://./Development/Test/DummyData.csv",
url = "file://localhost/C:/Users/Basti/ARBEIT Lokal/dsCCPhosClient/Development/Test/DummyData.csv",
format = "csv")
CCPConnections <- ConnectToVirtualCCP(CCPTestData = TestData,
NumberOfServers = 3,
NumberOfPatientsPerServer = 2000,
AddedDsPackages = "dsTidyverse",
Resources = list(TestResource = TestResource))
LoadRawDataSet(ServerSpecifications = NULL)
# Transform Raw Data Set (RDS) into Curated Data Set (CDS) (using default settings)
ds.CurateData(RawDataSetName = "RawDataSet",
Settings = NULL,
OutputName = "CurationOutput")
# Run ds.AugmentData
ds.AugmentData(CuratedDataSetName = "CuratedDataSet",
OutputName = "AugmentationOutput")
require(assertthat)
require(DSI)
require(purrr)
# --- For Testing Purposes ---
TableName <- "ADS_Patient"
FeatureNames <- c("Sex", "CountDiagnoses")
DSConnections <- CCPConnections
# Argument assertions
assert_that(is.string(TableName),
is.character(FeatureNames))
# Paste elements of 'FeatureNames' together and encode the resulting string to make it passable through DSI
FeatureNamesString <- paste0(FeatureNames, collapse = ", ") %>%
.encode_tidy_eval(.get_encode_dictionary())
devtools::load_all(".")
# Paste elements of 'FeatureNames' together and encode the resulting string to make it passable through DSI
FeatureNamesString <- paste0(FeatureNames, collapse = ", ") %>%
.encode_tidy_eval(.get_encode_dictionary())
# Get (maximum) number of unique values for selected features and multiply them to calculate the projected number of value combinations
ProjectedCombinations <- sapply(FeatureNames, function(featurename)
{ ds.GetFeatureInfo(TableName = TableName,
FeatureName = featurename) %>%
pull(CountUniqueValues) %>%
max(na.rm = TRUE)
}) %>%
prod(na.rm = TRUE)
rm(CCPConnections)
# Get (maximum) number of unique values for selected features and multiply them to calculate the projected number of value combinations
ProjectedCombinations <- sapply(FeatureNames, function(featurename)
{ ds.GetFeatureInfo(TableName = TableName,
FeatureName = featurename) %>%
pull(CountUniqueValues) %>%
max(na.rm = TRUE)
}) %>%
prod(na.rm = TRUE)
ProjectedCombinations
UserResponse <- readline(prompt = paste0("The features you selected will result in a high number of different value combinations (",
ProjectedCombinations,
"). This can result in low absolute frequencies for certain combinations, which could increase disclosure potential.\n",
"Do you want to continue? (y/n)"))
?readline
# Call server-side function
ServerReturns <- DSI::datashield.aggregate(conns = DSConnections,
expr = call("GetCrossTabDS",
TableName.S = TableName,
FeatureNames.S = FeatureNamesString))
CrossTab.Separate <- ServerReturns %>%
list_transpose(simplify = FALSE) %>%
pluck("CrossTab") %>%
list_rbind(names_to = "Server")
CrossTab.Cumulated <- CrossTab.Separate %>%
group_by(across(all_of(FeatureNames))) %>%
summarize(Server = "All",
Count = sum(Count, na.rm = TRUE),
ServersBelowThreshold = sum(NBelowThreshold == TRUE))
CrossTab <- CrossTab.Cumulated %>%
bind_rows(CrossTab.Separate)
View(CrossTab)
devtools::load_all(".")
library(dsBaseClient)
library(dsCCPhosClient)
library(dsTidyverseClient)
library(resourcer)
# Print DataSHIELD errors right away
options(datashield.errors.print = TRUE)
#TestData <- readRDS("../dsCCPhos/Development/Data/RealData/CCPRealData_Frankfurt.rds")
TestData <- readRDS("../dsCCPhos/Development/Data/TestData/CCPTestData.rds")
# Definition of test resource, exemplary with local csv-file
TestResource <- resourcer::newResource(name = "TestResource",
#url = "file://./Development/Test/DummyData.csv",
url = "file://localhost/C:/Users/Basti/ARBEIT Lokal/dsCCPhosClient/Development/Test/DummyData.csv",
format = "csv")
CCPConnections <- ConnectToVirtualCCP(CCPTestData = TestData,
NumberOfServers = 3,
NumberOfPatientsPerServer = 2000,
AddedDsPackages = "dsTidyverse",
Resources = list(TestResource = TestResource))
LoadRawDataSet(ServerSpecifications = NULL)
# Transform Raw Data Set (RDS) into Curated Data Set (CDS) (using default settings)
ds.CurateData(RawDataSetName = "RawDataSet",
Settings = NULL,
OutputName = "CurationOutput")
# Run ds.AugmentData
ds.AugmentData(CuratedDataSetName = "CuratedDataSet",
OutputName = "AugmentationOutput")
require(assertthat)
require(DSI)
require(purrr)
# --- For Testing Purposes ---
TableName <- "ADS_Patient"
FeatureNames <- c("Sex", "CountDiagnoses")
DSConnections <- CCPConnections
rm(CCPConnections)
# Argument assertions
assert_that(is.string(TableName),
is.character(FeatureNames))
# Paste elements of 'FeatureNames' together and encode the resulting string to make it passable through DSI
FeatureNamesString <- paste0(FeatureNames, collapse = ", ") %>%
.encode_tidy_eval(.get_encode_dictionary())
# Get (maximum) number of unique values for selected features and multiply them to calculate the projected number of value combinations
ProjectedCombinations <- sapply(FeatureNames, function(featurename)
{ ds.GetFeatureInfo(TableName = TableName,
FeatureName = featurename) %>%
pull(CountUniqueValues) %>%
max(na.rm = TRUE)
}) %>%
prod(na.rm = TRUE)
ProjectedCombinations
# Prompt user input when projected number of value combinations is high
if (ProjectedCombinations > 20)
{
UserResponse <- readline(prompt = paste0("The features you selected will result in a high number of different value combinations (",
ProjectedCombinations,
"). This can result in low absolute frequencies for certain combinations, which could increase disclosure potential.\n",
"Do you want to continue? (y/n) "))
if (!(UserResponse %in% c("Y", "y"))) { stop(call. = FALSE) }
}
# Call server-side function
ServerReturns <- DSI::datashield.aggregate(conns = DSConnections,
expr = call("GetCrossTabDS",
TableName.S = TableName,
FeatureNames.S = FeatureNamesString))
CrossTab.Separate <- ServerReturns %>%
list_transpose(simplify = FALSE) %>%
pluck("CrossTab") %>%
list_rbind(names_to = "Server")
CrossTab.Cumulated <- CrossTab.Separate %>%
group_by(across(all_of(FeatureNames))) %>%
summarize(Server = "All",
Count = sum(Count, na.rm = TRUE),
ServersBelowThreshold = sum(NBelowThreshold == TRUE))
CrossTab <- CrossTab.Cumulated %>%
bind_rows(CrossTab.Separate)
View(CrossTab)
MarginalCounts.Separate <- ServerReturns %>%
list_transpose(simplify = FALSE) %>%
pluck("MarginalCounts")
MarginalCounts.Separate$ServerA
ServerReturns$ServerA$MarginalCounts
ServerReturns$ServerB$ChiSq.PValue
ServerReturns$ServerB$MarginalCounts
ServerReturns$ServerC$MarginalCounts
# Call server-side function
ServerReturns <- DSI::datashield.aggregate(conns = DSConnections,
expr = call("GetCrossTabDS",
TableName.S = TableName,
FeatureNames.S = FeatureNamesString))
MarginalCounts.Separate <- ServerReturns %>%
list_transpose(simplify = FALSE)
MarginalCounts.Separate$MarginalCounts
Test <- getDSLiteData(conns = DSConnections, symbol = "ADS_Patient")
View(Test$ServerA)
View(Test$ServerC)
