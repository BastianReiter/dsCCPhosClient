name = "Ineligible",
color = I(dsCCPhosClient::CCPhosColors$Red)) %>%
add_trace(y = ~Missing,
name = "Missing",
color = I(dsCCPhosClient::CCPhosColors$MediumGrey)) %>%
layout(xaxis = list(categoryorder = "array",
categoryarray = c("Raw", "Harmonized", "Recoded", "Final")),
yaxis = list(title = "Count"),
barmode = "stack")
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Transform Curated Data Set (CDS) into Augmented Data Set (ADS)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Run ds.AugmentData
Messages <- ds.AugmentData(CuratedDataSetName = "CuratedDataSet",
OutputName = "AugmentationOutput",
DataSources = CCPConnections)
# Make tables from Augmented Data Set directly addressable by unpacking them into R server session
Messages <- ds.UnpackAugmentedDataSet(AugmentedDataSetName = "AugmentedDataSet",
DataSources = CCPConnections)
# For Testing Purposes
DataSources <- CCPConnections
TableName <- "ADS_Patients"
FeatureName <- "TimeDiagnosisToDeath"
GroupingFeatureName <- NULL
MaxNumberCategories <- NULL
RemoveMissingsInNumeric <- TRUE
# Get meta data of table object
TableMetaData <- ds.GetObjectMetaData(ObjectName = TableName,
DataSources = DataSources)
if (TableMetaData$FirstEligible$Class != "data.frame") { stop("Error: The referred table object does not seem to be a data.frame.", call. = FALSE)}
# Get data type of feature in question
FeatureType <- TableMetaData$FirstEligible$DataTypes[FeatureName]
# Initiate output object
Output <- tibble()      # Returned in this form only if no eligible feature type is present
ls_ParametricStatistics <- DSI::datashield.aggregate(conns = DataSources,
expr = call("GetSampleStatisticsDS",
TableName.S = TableName,
FeatureName.S = FeatureName,
GroupingFeatureName.S = GroupingFeatureName,
RemoveMissingsInNumeric.S = RemoveMissingsInNumeric))
ls_ParametricStatistics$SiteA$MetaData
ls_ParametricStatistics$SiteA$Statistics
ls_ParametricStatistics$SiteB$Statistics
Test <- ls_ParametricStatistics$SiteA$MetaData
Test$N_Valid > 0
devtools::load_all(".")
library(dsBaseClient)
library(dsCCPhosClient)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Establish Connections to virtual servers using dsCCPhosClient::ConnectToVirtualCCP()
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#TestData <- readRDS("../dsCCPhos/Development/Data/RealData/CCPRealData_Frankfurt.rds")
TestData <- readRDS("../dsCCPhos/Development/Data/TestData/CCPTestData.rds")
CCPConnections <- ConnectToVirtualCCP(CCPTestData = TestData,
NumberOfSites = 3,
NumberOfPatientsPerSite = 1000,
AddedDsPackages = "dsSurvivalFix")
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Check server requirements using dsCCPhosClient::CheckServerRequirements()
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
CheckServerRequirements(DataSources = CCPConnections)
# datashield.pkg_status(conns = CCPConnections)
# datashield.method_status(conns = CCPConnections)
# datashield.methods(conns = CCPConnections, type = "assign")
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Load Raw Data Set (RDS) from Opal data base to R sessions on servers
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Messages <- LoadRawDataSet(CCPSiteSpecifications = NULL,
DataSources = CCPConnections)
# Get validation report of Raw Data Set (RDS)
# ValidationReportRDS <- ds.GetValidationReport_RDS(Name_RawDataSet = "RawDataSet",
#                                                       DataSources = CCPConnections)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Transform Raw Data Set (RDS) into Curated Data Set (CDS)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Transform Raw Data Set (RDS) into Curated Data Set (CDS)
Messages <- ds.CurateData(RawDataSetName = "RawDataSet",
OutputName = "CurationOutput",
DataSources = CCPConnections)
# Make tables from Curated Data Set directly addressable by unpacking them into R server session
Messages <- ds.UnpackCuratedDataSet(CuratedDataSetName = "CuratedDataSet",
DataSources = CCPConnections)
# Get curation reports
CurationReports <- dsCCPhosClient::ds.GetCurationReport(DataSources = CCPConnections)
# Exemplary look at a curation report table
#View(CurationReports$All$Transformation$Monitors$Staging)
#View(CurationReports$All$Transformation$EligibilityOverviews$Staging)
#View(CurationReports$All$Transformation$ValueSetOverviews$Raw)
# Get validation report of Curated Data Set (CDS)
# ValidationReportCDS <- ds.GetValidationReport_CDS(Name_CurationOutput = "CurationOutput",
#                                                   DataSources = CCPConnections)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Plot data on value eligibility for exemplary table in CDS
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# - Restructure eligibility overview table to meet requirements of plot function
# - Create separate data frames for each 'Feature' value
# - Columns in final object:
#   - 'Feature': contains names of features
#   - 'data': plot data for feature-specific plot
#-------------------------------------------------------------------------------
PlotData <- CurationReports$All$Transformation$EligibilityOverviews$Staging %>%
select(-ends_with("_Proportional")) %>%
pivot_longer(cols = c(Raw, Harmonized, Recoded, Final),
names_to = "Stage",
values_to = "Count") %>%
pivot_wider(names_from = "Eligibility",
values_from = "Count") %>%
nest(.by = Feature)      # 'Split' the whole table into smaller data frames for each 'Feature' value
library(plotly)
plot_ly(data = filter(PlotData, Feature == "UICCStage")$data[[1]],
x = ~Stage,
y = ~Eligible,
type = "bar",
name = "Eligible",
color = I(dsCCPhosClient::CCPhosColors$Green)) %>%
add_trace(y = ~Ineligible,
name = "Ineligible",
color = I(dsCCPhosClient::CCPhosColors$Red)) %>%
add_trace(y = ~Missing,
name = "Missing",
color = I(dsCCPhosClient::CCPhosColors$MediumGrey)) %>%
layout(xaxis = list(categoryorder = "array",
categoryarray = c("Raw", "Harmonized", "Recoded", "Final")),
yaxis = list(title = "Count"),
barmode = "stack")
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Transform Curated Data Set (CDS) into Augmented Data Set (ADS)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Run ds.AugmentData
Messages <- ds.AugmentData(CuratedDataSetName = "CuratedDataSet",
OutputName = "AugmentationOutput",
DataSources = CCPConnections)
# Make tables from Augmented Data Set directly addressable by unpacking them into R server session
Messages <- ds.UnpackAugmentedDataSet(AugmentedDataSetName = "AugmentedDataSet",
DataSources = CCPConnections)
# For Testing Purposes
DataSources <- CCPConnections
TableName <- "ADS_Patients"
FeatureName <- "TimeDiagnosisToDeath"
GroupingFeatureName <- NULL
MaxNumberCategories <- NULL
RemoveMissingsInNumeric <- TRUE
# Get meta data of table object
TableMetaData <- ds.GetObjectMetaData(ObjectName = TableName,
DataSources = DataSources)
if (TableMetaData$FirstEligible$Class != "data.frame") { stop("Error: The referred table object does not seem to be a data.frame.", call. = FALSE)}
# Get data type of feature in question
FeatureType <- TableMetaData$FirstEligible$DataTypes[FeatureName]
ls_ParametricStatistics <- DSI::datashield.aggregate(conns = DataSources,
expr = call("GetSampleStatisticsDS",
TableName.S = TableName,
FeatureName.S = FeatureName,
GroupingFeatureName.S = GroupingFeatureName,
RemoveMissingsInNumeric.S = RemoveMissingsInNumeric))
ls_ParametricStatistics$SiteA$Statistics
ls_ParametricStatistics$SiteA$MetaData
FeatureName <- "IsDocumentedDeceases"
# Get meta data of table object
TableMetaData <- ds.GetObjectMetaData(ObjectName = TableName,
DataSources = DataSources)
if (TableMetaData$FirstEligible$Class != "data.frame") { stop("Error: The referred table object does not seem to be a data.frame.", call. = FALSE)}
# Get data type of feature in question
FeatureType <- TableMetaData$FirstEligible$DataTypes[FeatureName]
ls_ParametricStatistics <- DSI::datashield.aggregate(conns = DataSources,
expr = call("GetSampleStatisticsDS",
TableName.S = TableName,
FeatureName.S = FeatureName,
GroupingFeatureName.S = GroupingFeatureName,
RemoveMissingsInNumeric.S = RemoveMissingsInNumeric))
ls_ParametricStatistics$SiteA$MetaData
# Detailed meta data of a particular object (also part of ServerWorkspaceInfo)
ObjectMetaData <- ds.GetObjectMetaData(ObjectName = "ADS_Patients",
DataSources = CCPConnections)
# Explore Object meta data: Structural overview
View(ObjectMetaData$FirstEligible$Structure)
FeatureName <- "IsDocumentedDeceased"
# Get meta data of table object
TableMetaData <- ds.GetObjectMetaData(ObjectName = TableName,
DataSources = DataSources)
if (TableMetaData$FirstEligible$Class != "data.frame") { stop("Error: The referred table object does not seem to be a data.frame.", call. = FALSE)}
# Get data type of feature in question
FeatureType <- TableMetaData$FirstEligible$DataTypes[FeatureName]
ls_ParametricStatistics <- DSI::datashield.aggregate(conns = DataSources,
expr = call("GetSampleStatisticsDS",
TableName.S = TableName,
FeatureName.S = FeatureName,
GroupingFeatureName.S = GroupingFeatureName,
RemoveMissingsInNumeric.S = RemoveMissingsInNumeric))
ls_ParametricStatistics$SiteA$MetaData
ls_ParametricStatistics$SiteA$Statistics
FeatureName <- "TNM_T"
# Get meta data of table object
TableMetaData <- ds.GetObjectMetaData(ObjectName = TableName,
DataSources = DataSources)
if (TableMetaData$FirstEligible$Class != "data.frame") { stop("Error: The referred table object does not seem to be a data.frame.", call. = FALSE)}
# Get data type of feature in question
FeatureType <- TableMetaData$FirstEligible$DataTypes[FeatureName]
ls_ParametricStatistics <- DSI::datashield.aggregate(conns = DataSources,
expr = call("GetSampleStatisticsDS",
TableName.S = TableName,
FeatureName.S = FeatureName,
GroupingFeatureName.S = GroupingFeatureName,
RemoveMissingsInNumeric.S = RemoveMissingsInNumeric))
datashield.errors()
devtools::load_all(".")
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
library(dsBaseClient)
library(dsCCPhosClient)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Establish Connections to virtual servers using dsCCPhosClient::ConnectToVirtualCCP()
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#TestData <- readRDS("../dsCCPhos/Development/Data/RealData/CCPRealData_Frankfurt.rds")
TestData <- readRDS("../dsCCPhos/Development/Data/TestData/CCPTestData.rds")
CCPConnections <- ConnectToVirtualCCP(CCPTestData = TestData,
NumberOfSites = 3,
NumberOfPatientsPerSite = 1000,
AddedDsPackages = "dsSurvivalFix")
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Check server requirements using dsCCPhosClient::CheckServerRequirements()
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
CheckServerRequirements(DataSources = CCPConnections)
# datashield.pkg_status(conns = CCPConnections)
# datashield.method_status(conns = CCPConnections)
# datashield.methods(conns = CCPConnections, type = "assign")
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Load Raw Data Set (RDS) from Opal data base to R sessions on servers
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Messages <- LoadRawDataSet(CCPSiteSpecifications = NULL,
DataSources = CCPConnections)
# Get validation report of Raw Data Set (RDS)
# ValidationReportRDS <- ds.GetValidationReport_RDS(Name_RawDataSet = "RawDataSet",
#                                                       DataSources = CCPConnections)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Transform Raw Data Set (RDS) into Curated Data Set (CDS)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Transform Raw Data Set (RDS) into Curated Data Set (CDS)
Messages <- ds.CurateData(RawDataSetName = "RawDataSet",
OutputName = "CurationOutput",
DataSources = CCPConnections)
# Make tables from Curated Data Set directly addressable by unpacking them into R server session
Messages <- ds.UnpackCuratedDataSet(CuratedDataSetName = "CuratedDataSet",
DataSources = CCPConnections)
# Get curation reports
CurationReports <- dsCCPhosClient::ds.GetCurationReport(DataSources = CCPConnections)
# Exemplary look at a curation report table
#View(CurationReports$All$Transformation$Monitors$Staging)
#View(CurationReports$All$Transformation$EligibilityOverviews$Staging)
#View(CurationReports$All$Transformation$ValueSetOverviews$Raw)
# Get validation report of Curated Data Set (CDS)
# ValidationReportCDS <- ds.GetValidationReport_CDS(Name_CurationOutput = "CurationOutput",
#                                                   DataSources = CCPConnections)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Plot data on value eligibility for exemplary table in CDS
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# - Restructure eligibility overview table to meet requirements of plot function
# - Create separate data frames for each 'Feature' value
# - Columns in final object:
#   - 'Feature': contains names of features
#   - 'data': plot data for feature-specific plot
#-------------------------------------------------------------------------------
PlotData <- CurationReports$All$Transformation$EligibilityOverviews$Staging %>%
select(-ends_with("_Proportional")) %>%
pivot_longer(cols = c(Raw, Harmonized, Recoded, Final),
names_to = "Stage",
values_to = "Count") %>%
pivot_wider(names_from = "Eligibility",
values_from = "Count") %>%
nest(.by = Feature)      # 'Split' the whole table into smaller data frames for each 'Feature' value
library(plotly)
plot_ly(data = filter(PlotData, Feature == "UICCStage")$data[[1]],
x = ~Stage,
y = ~Eligible,
type = "bar",
name = "Eligible",
color = I(dsCCPhosClient::CCPhosColors$Green)) %>%
add_trace(y = ~Ineligible,
name = "Ineligible",
color = I(dsCCPhosClient::CCPhosColors$Red)) %>%
add_trace(y = ~Missing,
name = "Missing",
color = I(dsCCPhosClient::CCPhosColors$MediumGrey)) %>%
layout(xaxis = list(categoryorder = "array",
categoryarray = c("Raw", "Harmonized", "Recoded", "Final")),
yaxis = list(title = "Count"),
barmode = "stack")
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Transform Curated Data Set (CDS) into Augmented Data Set (ADS)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Run ds.AugmentData
Messages <- ds.AugmentData(CuratedDataSetName = "CuratedDataSet",
OutputName = "AugmentationOutput",
DataSources = CCPConnections)
# Make tables from Augmented Data Set directly addressable by unpacking them into R server session
Messages <- ds.UnpackAugmentedDataSet(AugmentedDataSetName = "AugmentedDataSet",
DataSources = CCPConnections)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Get overview of objects in server workspaces
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# - Using dsCCPhosClient::GetServerWorkspaceInfo() and dsCCPhosClient::ds.GetObjectMetaData()
#-------------------------------------------------------------------------------
# Collect comprehensive information about all workspace objects
ServerWorkspaceInfo <- GetServerWorkspaceInfo(DataSources = CCPConnections)
# Overview of all objects in server R sessions
View(ServerWorkspaceInfo$Overview)
# Detailed meta data of a particular object (also part of ServerWorkspaceInfo)
ObjectMetaData <- ds.GetObjectMetaData(ObjectName = "ADS_Patients",
DataSources = CCPConnections)
# Explore Object meta data: Structural overview
View(ObjectMetaData$FirstEligible$Structure)
# For Testing Purposes
DataSources <- CCPConnections
TableName <- "ADS_Patients"
FeatureName <- "TNM_T"
GroupingFeatureName <- NULL
MaxNumberCategories <- NULL
RemoveMissingsInNumeric <- TRUE
require(dsBaseClient)
require(dplyr)
# Get meta data of table object
TableMetaData <- ds.GetObjectMetaData(ObjectName = TableName,
DataSources = DataSources)
if (TableMetaData$FirstEligible$Class != "data.frame") { stop("Error: The referred table object does not seem to be a data.frame.", call. = FALSE)}
# Get data type of feature in question
FeatureType <- TableMetaData$FirstEligible$DataTypes[FeatureName]
ls_ParametricStatistics <- DSI::datashield.aggregate(conns = DataSources,
expr = call("GetSampleStatisticsDS",
TableName.S = TableName,
FeatureName.S = FeatureName,
GroupingFeatureName.S = GroupingFeatureName,
RemoveMissingsInNumeric.S = RemoveMissingsInNumeric))
ls_ParametricStatistics$SiteA$MetaData
ls_ParametricStatistics$SiteA$Statistics
FeatureName <- "PatientAgeAtDiagnosis"
# Get meta data of table object
TableMetaData <- ds.GetObjectMetaData(ObjectName = TableName,
DataSources = DataSources)
if (TableMetaData$FirstEligible$Class != "data.frame") { stop("Error: The referred table object does not seem to be a data.frame.", call. = FALSE)}
# Get data type of feature in question
FeatureType <- TableMetaData$FirstEligible$DataTypes[FeatureName]
ls_ParametricStatistics <- DSI::datashield.aggregate(conns = DataSources,
expr = call("GetSampleStatisticsDS",
TableName.S = TableName,
FeatureName.S = FeatureName,
GroupingFeatureName.S = GroupingFeatureName,
RemoveMissingsInNumeric.S = RemoveMissingsInNumeric))
ls_ParametricStatistics$SiteA$MetaData
ls_ParametricStatistics$SiteA$Statistics
ls_NonParametricStatistics_Split <- ds.quantileMean(x = paste0(TableName, "$", FeatureName),
type = "split",
datasources = DataSources)
ls_NonParametricStatistics_Split$SiteA
?ds.meanSdGp
ls_ParametricStatistics <- ds.meanSdGp(x = paste0(TableName, "$", FeatureName),
y = "1",
datasources = DataSources)
ls_ParametricStatistics$Mean_gp_study
ls_Statistics_Split <- DSI::datashield.aggregate(conns = DataSources,
expr = call("GetSampleStatisticsDS",
TableName.S = TableName,
FeatureName.S = FeatureName,
GroupingFeatureName.S = GroupingFeatureName,
RemoveMissingsInNumeric.S = RemoveMissingsInNumeric))
# Obtain SEPARATE parametric and non-parametric statistics for each server calling dsCCPhos::GetSampleStatisticsDS()
ls_Statistics_Separate <- DSI::datashield.aggregate(conns = DataSources,
expr = call("GetSampleStatisticsDS",
TableName.S = TableName,
FeatureName.S = FeatureName,
GroupingFeatureName.S = GroupingFeatureName,
RemoveMissingsInNumeric.S = RemoveMissingsInNumeric))
# Making use of dsBaseClient::ds.meadSdGp() to obtain CUMULATED parametric statistics
ls_ParametricStatistics_Cumulated <- ds.meanSdGp(x = paste0(TableName, "$", FeatureName),
y = "1",
datasources = DataSources)
# Making use of dsBaseClient::ds.quantileMean() to obtain CUMULATED non-parametric statistics
vc_NonParametricStatistics_Cumulated <- ds.quantileMean(x = paste0(TableName, "$", FeatureName),
type = "combine",
datasources = DataSources)
vc_NonParametricStatistics_Cumulated
?map_df
# Obtain SEPARATE parametric and non-parametric statistics for each server calling dsCCPhos::GetSampleStatisticsDS()
ls_SeparateStatistics <- DSI::datashield.aggregate(conns = DataSources,
expr = call("GetSampleStatisticsDS",
TableName.S = TableName,
FeatureName.S = FeatureName,
GroupingFeatureName.S = GroupingFeatureName,
RemoveMissingsInNumeric.S = RemoveMissingsInNumeric))
ls_SeparateStatistics$SiteA
df_Statistics <- ls_SeparateStatistics %>%
map(\(SiteReturn) SiteReturn$Statistics) %>%
list_rbind()
View(df_Statistics)
df_Statistics <- ls_SeparateStatistics %>%
map(\(SiteReturn) SiteReturn$Statistics) %>%
list_rbind() %>%
mutate(Site = names(DataSources))
View(df_Statistics)
?mutate
df_Statistics <- ls_SeparateStatistics %>%
map(\(SiteReturn) SiteReturn$Statistics) %>%
list_rbind() %>%
mutate(Site = names(DataSources), .before = 1)
View(df_Statistics)
# Making use of dsBaseClient::ds.meadSdGp() to obtain CUMULATED parametric statistics
ls_CumulatedStatistics_Parametric <- ds.meanSdGp(x = paste0(TableName, "$", FeatureName),
y = "1",
datasources = DataSources)
# Making use of dsBaseClient::ds.quantileMean() to obtain CUMULATED non-parametric statistics
vc_CumulatedStatistics_Nonparametric <- ds.quantileMean(x = paste0(TableName, "$", FeatureName),
type = "combine",
datasources = DataSources)
View(df_Statistics)
vc_CumulatedStatistics_Nonparametric
vc_CumulatedStatistics_Nonparametric$'5%'
vc_CumulatedStatistics_Nonparametric$`5%`
vc_CumulatedStatistics_Nonparametric["5%"]
# Obtain SEPARATE parametric and non-parametric statistics for each server calling dsCCPhos::GetSampleStatisticsDS()
ls_SeparateStatistics <- DSI::datashield.aggregate(conns = DataSources,
expr = call("GetSampleStatisticsDS",
TableName.S = TableName,
FeatureName.S = FeatureName,
GroupingFeatureName.S = GroupingFeatureName,
RemoveMissingsInNumeric.S = RemoveMissingsInNumeric))
# Convert site return into tibble containing separate statistics
df_SeparateStatistics <- ls_SeparateStatistics %>%
map(\(SiteReturn) SiteReturn$Statistics) %>%
list_rbind() %>%
mutate(Site = names(DataSources), .before = 1)
# Making use of dsBaseClient::ds.meadSdGp() to obtain CUMULATED parametric statistics
ls_CumulatedStatistics_Parametric <- ds.meanSdGp(x = paste0(TableName, "$", FeatureName),
y = "1",
datasources = DataSources)
# Making use of dsBaseClient::ds.quantileMean() to obtain CUMULATED non-parametric statistics
vc_CumulatedStatistics_Nonparametric <- ds.quantileMean(x = paste0(TableName, "$", FeatureName),
type = "combine",
datasources = DataSources)
# Compiling cumulated statistics
df_CumulatedStatistics <- tibble(Site = "All",
N = ls_CumulatedStatistics_Parametric$Nvalid_gp_study,
q5 = vc_CumulatedStatistics_Nonparametric["5%"],
Q1 = vc_CumulatedStatistics_Nonparametric["25%"],
Median = vc_CumulatedStatistics_Nonparametric["50%"],
Q3 = vc_CumulatedStatistics_Nonparametric["75%"],
q95 = vc_CumulatedStatistics_Nonparametric["95%"],
MAD = NA,
Mean = ls_CumulatedStatistics_Parametric$Mean_gp_study,
SD = ls_CumulatedStatistics_Parametric$StDev_gp_study,
SEM = ls_CumulatedStatistics_Parametric$SEM_gp_study)
df_Statistics <- bind_rows(df_SeparateStatistics,
df_CumulatedStatistics)
View(df_Statistics)
View(df_SeparateStatistics)
View(ls_CumulatedStatistics_Parametric)
View(df_CumulatedStatistics)
ls_CumulatedStatistics_Parametric$Nvalid_gp_study
ls_CumulatedStatistics_Parametric$Nvalid_gp_study["COMBINE"]
ls_CumulatedStatistics_Parametric$Nvalid_gp_study$COMBINE
ls_CumulatedStatistics_Parametric$Nvalid_gp_study[["COMBINE"]]
ls_CumulatedStatistics_Parametric$Nvalid_gp_study["COMBINE"]
Test <- ls_CumulatedStatistics_Parametric$Nvalid_gp_study
View(Test)
Test[1, "COMBINE"]
Test <- ls_CumulatedStatistics_Parametric$Nvalid_gp_study[1, "COMBINE"]
# Compiling cumulated statistics
df_CumulatedStatistics <- tibble(Site = "All",
N = ls_CumulatedStatistics_Parametric$Nvalid_gp_study[1, "COMBINE"],
q5 = vc_CumulatedStatistics_Nonparametric["5%"],
Q1 = vc_CumulatedStatistics_Nonparametric["25%"],
Median = vc_CumulatedStatistics_Nonparametric["50%"],
Q3 = vc_CumulatedStatistics_Nonparametric["75%"],
q95 = vc_CumulatedStatistics_Nonparametric["95%"],
MAD = NA,
Mean = ls_CumulatedStatistics_Parametric$Mean_gp_study,
SD = ls_CumulatedStatistics_Parametric$StDev_gp_study,
SEM = ls_CumulatedStatistics_Parametric$SEM_gp_study)
df_Statistics <- bind_rows(df_SeparateStatistics,
df_CumulatedStatistics)
View(df_Statistics)
ls_CumulatedStatistics_Parametric$Mean_gp_study
# Compiling cumulated statistics
df_CumulatedStatistics <- tibble(Site = "All",
N = ls_CumulatedStatistics_Parametric$Nvalid_gp_study[1, "COMBINE"],
q5 = vc_CumulatedStatistics_Nonparametric["5%"],
Q1 = vc_CumulatedStatistics_Nonparametric["25%"],
Median = vc_CumulatedStatistics_Nonparametric["50%"],
Q3 = vc_CumulatedStatistics_Nonparametric["75%"],
q95 = vc_CumulatedStatistics_Nonparametric["95%"],
MAD = NA,
Mean = ls_CumulatedStatistics_Parametric$Mean_gp_study[1, "COMBINE"],
SD = ls_CumulatedStatistics_Parametric$StDev_gp_study[1, "COMBINE"],
SEM = ls_CumulatedStatistics_Parametric$SEM_gp_study[1, "COMBINE"])
df_Statistics <- bind_rows(df_SeparateStatistics,
df_CumulatedStatistics)
View(df_Statistics)
(25.7 + 34.25 + 26.8) / 3
(55+55+51) / 3
(55*75+55*86+51*97)/258
# Convert site return into tibble containing separate statistics
df_MetaData <- ls_SeparateStatistics %>%
map(\(SiteReturn) SiteReturn$MetaData) %>%
list_rbind() %>%
mutate(Site = names(DataSources), .before = 1)
View(df_MetaData)
?add_row
?ds.quantileMean
Test <- ds.summary(x = "ADS_Patients$PatientAgeAtDiagnosis",
datasources = DataSources)
Test
# Convert site return into tibble containing separate statistics
df_SeparateMetaData <- ls_SeparateStatistics %>%
map(\(SiteReturn) SiteReturn$MetaData) %>%
list_rbind() %>%
mutate(Site = names(DataSources), .before = 1)
